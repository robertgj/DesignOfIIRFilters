<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    Design of IIR Filters
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="shortcut icon" href="/public/favicon.ico">
</head>


  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
            type="text/javascript">
    </script>

    <div class="container content">
      <main>
        <article class="post">
  <h1 class="post-title">On the Design of IIR Filters</h1>
  <time datetime="2017-08-23T00:00:00+10:00" class="post-date">23 Aug 2017</time>
  <p>An <em>Infinite-Impulse-Response</em> (IIR) filter can approximate a desired response
with fewer coefficients than a <em>Finite-Impulse-Response</em> (FIR) filter. An FIR
filter design problem can be formulated as a convex optimisation problem with
a global solution. The design of IIR filters is more difficult than the design
of FIR filters. The coefficient-response surface of an IIR filter rational
polynomial transfer function is more complicated than that of an FIR polynomial
transfer function. An IIR filter design procedure must find a locally optimal
solution that satisfies the response specifications and the coefficients of
the IIR transfer function denominator polynomial must be constrained to ensure
that the IIR filter is stable.</p>

<p>The document
<a href="/public/DesignOfIIRFilters.pdf">DesignOfIIRFilters.pdf</a>
reports my experiments in the design of IIR filters with specified
amplitude, phase and group delay responses and truncated or quantised
coefficients. The repository <a href="https://github.com/robertgj/DesignOfIIRFilters">https://github.com/robertgj/DesignOfIIRFilters</a>
contains the files required to generate the figures and results shown in that
document. I programmed these experiments in the
<a href="https://www.gnu.org/software/octave">Octave</a> language. Octave is an 
<a href="https://wiki.octave.org/FAQ#Differences_between_Octave_and_Matlab"><em>almost</em></a>
compatible open-source-software clone of the commercial
<a href="http://mathworks.com">MATLAB</a> package.</p>

<p>The <em>Minimum-Mean Squared Error</em> (MMSE)
approximation to the required IIR filter response is found by either a
<em>Sequential-Quadratic-Programming</em> (SQP) solver or by the
<a href="https://github.com/sqlp/sedumi">SeDuMi</a> <em>Second-Order-Cone-Programming</em>
(SOCP) solver. The stability of the filter is ensured by constraining the pole
locations of the filter transfer function when expressed in <em>gain-pole-zero</em>
form or by constraining the <em>reflection coefficients</em> of a tapped all-pass
lattice filter implementation. A valid initial solution for the MMSE solver is
found by <em>eye</em> or by unconstrained optimisation with a <em>penalty</em> function.
Response constraints are applied with a <em>Peak-Constrained-Least-Squares</em> (PCLS)
exchange algorithm.</p>

<p>The lattice filter has good round-off noise and coefficient
sensitivity performance when implemented with integer coefficients. For
coefficient word lengths greater than 10-bits the coefficients are allocated
signed-digits and <em>branch-and-bound</em> or <em>relaxation</em> search is used to find an
acceptable response. For lesser coefficient word-lengths <em>simulated-annealing</em>
gives the best results.</p>

<h2 id="optimising-the-iir-filter-frequency-response">Optimising the IIR filter frequency response</h2>
<p>One formulation of the filter optimisation problem is to
minimise the <em>weighted-squared-error</em> of the frequency response:</p>

<blockquote>
  <p><strong>minimise</strong>
\(E_{H}(x)=\int W(\omega)\left|H(x,\omega)-H_{d}(\omega)\right|^{2}d\omega\)</p>

  <p><strong>subject to</strong> \(H\) is stable</p>
</blockquote>

<p>where \(x\) is the coefficient vector of the filter, \(E_{H}\) is
the weighted sum of the squared error, \(W(\omega)\) is the
frequency weighting, \(H(x,\omega)\) is the filter frequency
response and \(H_{d}(\omega)\) is the desired filter frequency
response. The solution proceeds by choosing an initial coefficient vector
and calling the SQP solver to find the coefficient vector that
optimises a second-order approximation to \(E_{H}\). The solution is
repeated until the difference between successive errors or
successive coefficient vectors is sufficiently small.</p>

<p>Alternatively, the optimisation problem can be expressed as a
<em>weighted-mini-max</em> problem:</p>

<blockquote>
  <p><strong>minimise max</strong>
\(W(\omega)\left|H(x,\omega)-H_{d}(\omega)\right|\)</p>

  <p><strong>subject to</strong> \(H\) is stable</p>
</blockquote>

<p>Similarly, in this case, given an initial coefficient vector, the
solution proceeds by calling the SOCP solver to find the coefficient vector
that minimises the maximum error of a first-order approximation to \(H\).</p>

<p>When optimising the coefficients of the filter with integer values, the
<em>relaxation</em> solution proceeds by fixing a coefficient and optimising the
response over the remaining coefficients, repeating until all coefficients
have been fixed.</p>

<p>The following plot compares the pass-band and stop-band
amplitude responses and pass-band group delay responses for a one-multiplier
tapped all-pass lattice bandpass filter with a transfer function of order 20
and with denominator polynomial coefficients only in powers of \(z^{2}\).
The plot compares the responses with exact coefficients and with 10 bit integer
coefficients found by allocating an average of 3 signed-digits to each
coefficient and performing SQP-relaxation optimisation. The optimised
coefficient multiplications are implemented with 61 signed-digits and 31
shift-and-add operations.</p>

<p><img src="/public/sqp_relaxation_bandpass_OneM_lattice_10_nbits_test_intro.svg" alt="" title="Comparison of the responses of a
one-multiplier lattice band-pass filter with exact coefficients and 
3-signed-digit integer coefficients optimised with SQP-relaxation." /></p>

<h2 id="reproducing-my-results">Reproducing my results</h2>
<p>The Octave scripts included in this repository generate long sequences of
floating point operations. The results shown in the report were obtained on
my system running with a particular combination of CPU architecture, operating
system, library versions, compiler version and Octave version.
<strong>Your system will almost certainly be different.</strong>
<strong>You may need to modify a script to run on your system</strong>.</p>

<h2 id="about-this-page">About this page</h2>
<p>This page was generated by the <a href="http://jekyllrb.com">Jekyll</a> static site
generator using the <a href="http://getpoole.com">Poole</a> theme by
<a href="/LICENSE.md">Mark Otto</a>. The equations were rendered by
<a href="https://www.mathjax.org/">MathJax</a>.</p>


</article>



      </main>
    </div>

    
  </body>
</html>
