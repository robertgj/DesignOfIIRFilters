--- sedumi/dpr1fact.c	2020-08-22 00:32:28.649167173 +1000
+++ SeDuMi_1_3/dpr1fact.c	2020-08-22 00:32:43.893019475 +1000
@@ -365,6 +365,7 @@
    ------------------------------------------------------------ */
   else{
     psqrdep = 0.0;
+    j = 0;
     for(i = 0; dep[i] < m; i++)
       if(psqr[dep[i]] > psqrdep){
         j = i;
--- sedumi/vecsym.c	2020-08-22 00:32:28.717166514 +1000
+++ SeDuMi_1_3/vecsym.c	2020-08-22 00:32:43.889019514 +1000
@@ -139,10 +139,8 @@
 void mexFunction(const int nlhs, mxArray *plhs[],
   const int nrhs, const mxArray *prhs[])
 {
- mxArray *output_array[1], *Xk;
-
  coneK cK;
- mwIndex k, nk, nksqr, lqDim,lenfull;
+ mwIndex lqDim, lenfull;
  const double *x;
  double *y;
 
--- sedumi/trydif.m	2020-08-22 00:32:28.716166524 +1000
+++ SeDuMi_1_3/trydif.m	2020-08-22 00:32:43.887019533 +1000
@@ -52,7 +52,7 @@
     halfxz = (x(ix(1):ix(2)-1).*z(ix(1):ix(2)-1)...
         + ddot(x(ix(2):ix(3)-1),z,K.qblkstart)) / 2;
     tmp = halfxz.^2 - detxz;
-    if tmp > 0
+    if all(tmp > 0)
         lab2q = halfxz + sqrt(tmp);
     else
         lab2q = halfxz;
--- sedumi/bwblkslv.c	2020-08-22 00:32:28.637167289 +1000
+++ SeDuMi_1_3/bwblkslv.c	2020-08-22 00:32:43.896019446 +1000
@@ -186,7 +186,7 @@
  mwIndex m,n, j, k, nsuper, inz;
  double *y, *fwork;
  const double *permPr, *b, *xsuperPr;
- const mwIndex *yjc, *yir, *bjc, *bir;
+ const mwIndex *yjc=NULL, *yir=NULL, *bjc=NULL, *bir=NULL;
  mwIndex *perm, *xsuper, *iwork, *snode;
  jcir L;
  char bissparse;
--- sedumi/widelen.m	2020-08-22 00:32:28.718166505 +1000
+++ SeDuMi_1_3/widelen.m	2020-08-22 00:32:43.886019543 +1000
@@ -91,7 +91,7 @@
         halfxz = (xM(ix(1):ix(2)-1).*zM(ix(1):ix(2)-1)...
             + ddot(xM(ix(2):ix(3)-1),zM,K.qblkstart)) / 2;
         tmp = halfxz.^2 - detxz;
-        if tmp > 0
+        if all(tmp > 0)
             lab2q = halfxz + sqrt(tmp);
         else
             lab2q = halfxz;
--- sedumi/symfctmex.c	2020-08-22 00:32:28.715166533 +1000
+++ SeDuMi_1_3/symfctmex.c	2020-08-22 00:32:43.900019407 +1000
@@ -136,7 +136,6 @@
     *invp, *colcnt;
   mxArray *L_FIELD;
   const char *LFieldnames[] = {"L", "perm", "xsuper"};
-  mwIndex *mwXjc, *mwXir, *mwLjc, *mwLir;
 /* ------------------------------------------------------------
    Check for proper number of arguments
    ------------------------------------------------------------ */
--- sedumi/blkchol2.c	2020-08-22 00:32:28.637167289 +1000
+++ SeDuMi_1_3/blkchol2.c	2020-08-22 00:32:43.901019397 +1000
@@ -113,7 +113,12 @@
    ------------------------------------------------------- */
     xkk = x[inz];
     if(xkk > lb[k]){ /* now xkk > 0 */
-      if(xkk < ub){
+/* ------------------------------------------------------------
+   maxabs is a wrapper for the BLAS IDAMAX Fortran function.
+   IDAMAX finds the first element having maximum absolute
+   value in an array. Only call maxabs with m>1. 
+   ------------------------------------------------------------ */
+      if ((m>1) && (xkk < ub)){
         ubk = maxabs(x+inz+1,m-1) / maxu;
         if(xkk < ubk){
 /* ------------------------------------------------------------
--- sedumi/maxstep.m	2020-08-22 00:32:28.701166669 +1000
+++ SeDuMi_1_3/maxstep.m	2020-08-22 00:32:43.887019533 +1000
@@ -50,7 +50,7 @@
     reltr = x(ix(1):ix(2)-1).*dx(ix(1):ix(2)-1)...
         - ddot(x(ix(2):ix(3)-1),dx,K.qblkstart);
     norm2 = reltr.^2 - tdet(dx,K).*auxx.tdet;
-    if norm2 > 0
+    if all(norm2 > 0)
         norm2 = sqrt(norm2);
     end
     mindxq = min( (reltr - norm2)./auxx.tdet);
--- sedumi/sedumi.m	2020-08-22 00:32:28.712166563 +1000
+++ SeDuMi_1_3/sedumi.m	2020-08-22 00:32:43.904019368 +1000
@@ -264,7 +264,11 @@
 if N*m<100000
     %Test if Ax=b is feasible at all
     %turn off the rank deficient warning for now
+    if (exist ('OCTAVE_VERSION', 'builtin') == 5)
+      s = warning('off','Octave:singular-matrix');
+    else
     s = warning('off','MATLAB:singularMatrix');
+    endif
     y=[A;b']\[zeros(N,1);1];
     if abs(y'*b-1) < 1e-10 && norm(A*y) < 1e-10
         %Infeasibility certificate found
@@ -778,8 +782,6 @@
     info.err(1)=norm(x'*(origcoeff.At)-(origcoeff.b)',2)/(1+normb);
     %Let us get rid of the K.f part, since the free variables don't make
     %any difference in the cone infeasibility.
-    %origcoeff.K.f=0;
-
     if origcoeff.K.f<length(origcoeff.c)
         %not all primal variables are free
         %     Primal cone infeasibility
@@ -788,13 +790,9 @@
         info.err(2)=max(0,-min(eigK(full(x(origcoeff.K.f+1:end)),tempK)/(1+normb)));
         %     Dual cone infeasibility
         info.err(4)=max(0,-min(eigK(full(s(origcoeff.K.f+1:end)),tempK)/(1+normc)));
-        
-    else
-        info.err(2)=0;
-        info.err(4)=0;
     end
     %     Dual infeasibility
-    %info.err(3)=0.0; %s is not maintained explicitely
+    info.err(3)=0.0; % not maintained explicitly
         %     Relative duality gap
     info.err(5)=(cx-by)/(1+abs(cx)+abs(by));
     %     Relative complementarity
--- sedumi/sqrtinv.c	2020-08-22 00:32:28.713166553 +1000
+++ SeDuMi_1_3/sqrtinv.c	2020-08-22 00:32:43.890019504 +1000
@@ -95,7 +95,7 @@
 void mexFunction(const int nlhs, mxArray *plhs[],
   const int nrhs, const mxArray *prhs[])
 {
-  mwIndex i,k, nk, nksqr, lenud, lendiag, diagskip;
+  mwIndex k, nk, nksqr, lenud, lendiag, diagskip;
   double *y;
   const double *q,*v;
   coneK cK;
--- sedumi/spscale.c	2020-08-22 00:32:28.713166553 +1000
+++ SeDuMi_1_3/spscale.c	2020-08-22 00:32:43.909019320 +1000
@@ -76,6 +76,7 @@
 {
   mwIndex knz, jfirst, jlast, inz, i, j;
   knz = 0;        /* length(ycols) */
+  jfirst = 0;
   jlast = 0;      /* index right after last activated column */
   y -= n;         /* point to dummy column, which will be skipped */
 /* ------------------------------------------------------------
@@ -133,6 +134,7 @@
   const double *dpi;
   char found;
   knz = 0;        /* length(ycols) */
+  jfirst = 0;
   jlast = 0;      /* index right after last activated column */
   nsqr = SQR(n);
   dpi = d + nsqr;
@@ -251,7 +253,7 @@
 {
   mwIndex inz, i, icol, j, jfirst, jlast, m;
   double *xd;
-  const double *dj, *xdj;
+  const double *dj=NULL, *xdj=NULL;
 /* ------------------------------------------------------------
    Partition 2*n^2 WORKING array fwork into [fwork(n^2), xd(n^2)].
    ------------------------------------------------------------ */
@@ -276,6 +278,7 @@
    zij = (D*sym(X)*D)_ij = [ DXD_ij + DXD_ji ] /2.
    Note that DXD_ij = xd(:,i)' * fwork(:,j).   (m mults)
    ------------------------------------------------------------ */
+  jfirst = 0;
   jlast = 0;      /* index right after last activated column */
   for(inz = 0; inz < znnz; inz++){
     if((i = zir[inz]) >= jlast){      /* move to new z-column */
@@ -334,7 +337,8 @@
   mwIndex inz, i, icol, j, jfirst, jlast, m, nsqr, imgfirst;
   double *dx, *dxpi, *fworkpi;
   double zi;
-  const double *dj, *djpi, *djx, *djxpi;
+  const double *dj=NULL, *djpi=NULL, *djx=NULL, *djxpi=NULL;
+  jfirst = 0;
   nsqr = SQR(n);
 /* ------------------------------------------------------------
    Partition 4*n^2 WORKING array fwork into [fwork(2*n^2), dxRows(2*n^2)].
--- sedumi/fwblkslv.c	2020-08-22 00:32:28.692166756 +1000
+++ SeDuMi_1_3/fwblkslv.c	2020-08-22 00:32:43.916019252 +1000
@@ -197,7 +197,7 @@
  mwIndex m,n, j, k, nsuper, inz;
  double *y,*fwork;
  const double *permPr, *b, *xsuperPr;
- const mwIndex *yjc, *yir, *bjc, *bir;
+ const mwIndex *yjc=NULL, *yir=NULL, *bjc=NULL, *bir=NULL;
  mwIndex *perm, *invperm, *snode, *xsuper, *iwork;
  jcir L;
  char bissparse;
--- sedumi/psdframeit.c	2020-08-22 00:32:28.707166611 +1000
+++ SeDuMi_1_3/psdframeit.c	2020-08-22 00:32:43.878019620 +1000
@@ -107,7 +107,7 @@
 void mexFunction(const int nlhs, mxArray *plhs[],
   const int nrhs, const mxArray *prhs[])
 {
-  mwIndex i,lendiag, lenfull, lenud,qsize;
+  mwIndex i, lendiag, lenud, qsize;
   double *x, *fwork;
   const double *lab,*frms;
   mwIndex *sdpNL;
@@ -126,7 +126,6 @@
    ------------------------------------------------------------ */
   lenud = cK.rDim + cK.hDim;
   qsize = lenud + cK.hLen;
-  lenfull = cK.lpN +  cK.qDim + lenud;
   lendiag = cK.lpN + 2 * cK.lorN + cK.rLen + cK.hLen;
 /* ------------------------------------------------------------
    Get inputs lab,frms
--- sedumi/extractA.c	2020-08-22 00:32:28.690166776 +1000
+++ SeDuMi_1_3/extractA.c	2020-08-22 00:32:43.886019543 +1000
@@ -98,7 +98,7 @@
                  int nrhs, const mxArray *prhs[])
 {
   jcir At, Apart;
-  mwIndex i, m, njc, ifirst, n, ynnz, blk0,blk1;
+  mwIndex i, m, njc, ifirst=0, n=0, ynnz, blk0, blk1;
   mwIndex *Ajc;
   const double *blkstartPr, *AjcPr;
   bool isblk0negative;
--- sedumi/urotorder.c	2020-08-22 00:32:28.716166524 +1000
+++ SeDuMi_1_3/urotorder.c	2020-08-22 00:32:43.889019514 +1000
@@ -90,6 +90,7 @@
    ------------------------------------------------------------ */
   for(j = 0; j < n; j++)
     perm[j] = j;
+  pivk = 0;
   inz = 0;
   d[0] = 0.0; h = 1.0;
   for(k = 0, rowuk = u; k < n-1; k++, rowuk++){
@@ -208,6 +209,7 @@
    ------------------------------------------------------------ */
   for(j = 0; j < n; j++)
     perm[j] = j;
+  pivk = 0;
   inz = 0;
   d[0] = 0.0; h = 1.0;
   for(k = 0, rowuk = u, rowukpi = upi; k < n-1; k++, rowuk++, rowukpi++){
@@ -311,8 +313,8 @@
   const int nrhs, const mxArray *prhs[])
 {
   mxArray *myplhs[NPAROUT];
-  mwIndex i,j,k, nk, nksqr, lenud, sdplen, gnnz, inz, maxKs,maxKssqr, rgnnz, hgnnz;
-  const double *uOld, *permOld;
+  mwIndex i, k, nk, nksqr, lenud, sdplen, gnnz, inz, maxKs, maxKssqr, rgnnz, hgnnz;
+  const double *uOld, *permOld=NULL;
   double *u, *d, *gjcPr, *permPr, *fwork, *fworkpi;
   mwIndex *perm, *gjc;
   double *g, *gk;
