--- sedumi-master/blkchol2.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/blkchol2.c	2018-06-18 21:42:12.000000000 +1000
@@ -53,7 +53,7 @@ mwIndex blkLDL(const mwIndex neqns, cons
 void isscalarmul(double *x, double alpha, mwIndex n)
 {
     blasint one=1,nn=n;
-    FORT(dscal)(&n,&alpha,x,&one);
+    FORT(dscal)(&nn,&alpha,x,&one);
 }
 
 /* ************************************************************
@@ -113,7 +113,7 @@ void cholonBlk(double *x, double *d, mwI
    ------------------------------------------------------- */
     xkk = x[inz];
     if(xkk > lb[k]){ /* now xkk > 0 */
-      if(xkk < ub){
+      if((m>1) && (xkk < ub)){
         ubk = maxabs(x+inz+1,m-1) / maxu;
         if(xkk < ubk){
 /* ------------------------------------------------------------
--- sedumi-master/dpr1fact.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/dpr1fact.c	2017-06-08 12:37:40.000000000 +1000
@@ -365,7 +365,7 @@ char dodpr1fact(double *beta, mwIndex *p
    ------------------------------------------------------------ */
   else{
     psqrdep = 0.0;
-    for(i = 0; dep[i] < m; i++)
+    for(i = 0, j=0; dep[i] < m; i++)
       if(psqr[dep[i]] > psqrdep){
         j = i;
         psqrdep = psqr[dep[i]];
--- sedumi-master/eigK.m	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/eigK.m	2017-06-08 12:37:40.000000000 +1000
@@ -74,7 +74,7 @@ end
 li = 0;
 xi = nf;
 lab = zeros(N,1);
-li(li+1:li+nl) = x(xi+1:xi+nl);
+lab(li+1:li+nl) = x(xi+1:xi+nl);
 xi = xi + nl;
 li = li + nl;
 if nq,
--- sedumi-master/extractA.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/extractA.c	2017-06-08 12:37:40.000000000 +1000
@@ -98,7 +98,7 @@ void mexFunction(int nlhs, mxArray *plhs
                  int nrhs, const mxArray *prhs[])
 {
   jcir At, Apart;
-  mwIndex i, m, njc, ifirst, n, ynnz, blk0,blk1;
+  mwIndex i, m, njc, ifirst=0, n=0, ynnz, blk0,blk1;
   mwIndex *Ajc;
   const double *blkstartPr, *AjcPr;
   bool isblk0negative;
--- sedumi-master/install_sedumi.m	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/install_sedumi.m	2017-11-21 23:10:24.000000000 +1100
@@ -36,6 +36,8 @@ function install_sedumi( varargin )
 
 need_rebuild = any( strcmp( varargin, '-rebuild' ) );
 no_path = any( strcmp( varargin, '-nopath' ) );
+address_sanitize = any( strcmp( varargin, '-address_sanitize' ) );
+enable_64bits = any( strcmp( varargin, '-enable_64bits' ) );
 
 targets64={...
     'bwblkslv.c sdmauxFill.c sdmauxRdot.c',...
@@ -163,9 +165,21 @@ if need_rebuild,
         if VERSION < 3.08,
             flags{end+1} = '-DmwSignedIndex=int';
         end
+        if address_sanitize
+          flags{end+1} = '-fsanitize=address -fsanitize=undefined';
+          flags{end+1} = '-fsanitize=leak -fno-sanitize=vptr';
+          flags{end+1} = '-fno-omit-frame-pointer';
+          flags{end+1} = '-g -O0';
+        else
         flags{end+1} = '-O';
+        endif
+        if enable_64bits
+          flags{end+1} = '-DOPENBLAS_USE64BITINT'
+        endif
         flags{end+1} = '-DOCTAVE';
-        libs{end+1} = '-lblas';
+        flags{end+1} = '-Wall'
+        flags{end+1} = '-Wno-unused-variable';
+        flags{end+1} = '-Wno-unused-but-set-variable';
     else
         flags{end+1} = '-O';
         if IS64BIT && ( VERSION >= 7.03 ),
@@ -209,6 +223,7 @@ if need_rebuild,
         mfile = [ targ(1:min(strfind(targ,'.'))), mext ];
         temp = [ 'mex ', flags, ' ', targets64{i}, libs ];
         fprintf( '   %s: %s\n', mfile, targ );
+	disp( temp );
         eval( temp, 'failed=true;' ); %#ok
     end
     cd( olddir );
--- sedumi-master/ordmmdmex.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/ordmmdmex.c	2017-06-08 12:37:40.000000000 +1000
@@ -39,6 +39,12 @@
 
 #include "mex.h"
 
+/* Prototype from ordmmd.c */
+typedef mwSignedIndex integer;                  /* removed "long" */
+extern int ordmmd_(integer *neqns, integer *xadj, integer *adjncy,
+                   integer *invp, integer *perm, integer *iwsiz,
+                   integer *iwork, integer *nofsub, integer *iflag);
+
 #define PERM_OUT plhs[0]
 
 #define X_IN prhs[0]
--- sedumi-master/sdmauxRdot.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/sdmauxRdot.c	2018-06-18 21:42:12.000000000 +1000
@@ -53,6 +53,6 @@ double realdot(const double *x, const do
    ************************************************************ */
 double realssqr(const double *x, const mwIndex n)
 {
-    mwIndex one=1,nn=n;
+    blasint one=1,nn=n;
     return FORT(ddot)(&nn,(double*)x,&one,(double*)x,&one);
 }
--- sedumi-master/sedumi.m	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/sedumi.m	2017-06-08 12:37:40.000000000 +1000
@@ -805,7 +805,7 @@ if ~isempty(origcoeff)
         info.err(4)=0;
     end
     %     Dual infeasibility
-    %info.err(3)=0.0; %s is not maintained explicitely
+    info.err(3)=0.0; %s is not maintained explicitely
         %     Relative duality gap
     info.err(5)=(cx-by)/(1+abs(cx)+abs(by));
     %     Relative complementarity
--- sedumi-master/spscale.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/spscale.c	2017-06-08 12:37:40.000000000 +1000
@@ -74,7 +74,7 @@ mwIndex realdmulx(double *y, mwIndex *yc
               const double *xpr, const mwIndex *xir, mwIndex *pxjc0, const mwIndex xjc1,
               const mwIndex first, const mwIndex n)
 {
-  mwIndex knz, jfirst, jlast, inz, i, j;
+  mwIndex knz, jfirst=0, jlast, inz, i, j;
   knz = 0;        /* length(ycols) */
   jlast = 0;      /* index right after last activated column */
   y -= n;         /* point to dummy column, which will be skipped */
@@ -128,7 +128,7 @@ mwIndex cpxdmulx(double *y, mwIndex *yco
              const double *xpr, const mwIndex *xir, mwIndex *pxjc0, const mwIndex xjc1,
              const mwIndex first, const mwIndex n)
 {
-  mwIndex jfirst, jlast, inz, jnz, knz, i, j, icol, imgfirst, nsqr, ncols;
+  mwIndex jfirst=0, jlast, inz, jnz, knz, i, j, icol, imgfirst, nsqr, ncols;
   double *ypr, *ypi;
   const double *dpi;
   char found;
@@ -249,9 +249,9 @@ void sprealdxd(double *z, const mwIndex
                const double *xpr, const mwIndex *xir, mwIndex *pxjc0, const mwIndex xjc1,
                const mwIndex first, const mwIndex n, double *fwork, mwIndex *dxcols)
 {
-  mwIndex inz, i, icol, j, jfirst, jlast, m;
+  mwIndex inz, i, icol, j, jfirst=0, jlast, m;
   double *xd;
-  const double *dj, *xdj;
+  const double *dj=NULL, *xdj=NULL;
 /* ------------------------------------------------------------
    Partition 2*n^2 WORKING array fwork into [fwork(n^2), xd(n^2)].
    ------------------------------------------------------------ */
@@ -331,10 +331,10 @@ void spcpxdxd(double *z, const mwIndex *
               const double *xpr, const mwIndex *xir, mwIndex *pxjc0, const mwIndex xjc1,
               const mwIndex first, const mwIndex n, double *fwork, mwIndex *dxcols)
 {
-  mwIndex inz, i, icol, j, jfirst, jlast, m, nsqr, imgfirst;
+  mwIndex inz, i, icol, j, jfirst=0, jlast, m, nsqr, imgfirst;
   double *dx, *dxpi, *fworkpi;
   double zi;
-  const double *dj, *djpi, *djx, *djxpi;
+  const double *dj=NULL, *djpi=NULL, *djx=NULL, *djxpi=NULL;
   nsqr = SQR(n);
 /* ------------------------------------------------------------
    Partition 4*n^2 WORKING array fwork into [fwork(2*n^2), dxRows(2*n^2)].
--- sedumi-master/statsK.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/statsK.c	2017-06-08 12:37:40.000000000 +1000
@@ -126,6 +126,7 @@ void mexFunction(int nlhs, mxArray *plhs
   conepars(K_IN, &cK);
   if( (K_FIELD = mxGetField(K_IN,(mwIndex)0,"ycomplex")) == NULL){  /* K.ycomplex */
     nycomplex = 0;
+    ycomplexPr = 0;
   }
   else{
     nycomplex = mxGetM(K_FIELD) * mxGetN(K_FIELD);
--- sedumi-master/symfctmex.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/symfctmex.c	2017-06-08 12:37:40.000000000 +1000
@@ -40,6 +40,18 @@
 
 #include "mex.h"
 
+/* Prototypes from symfct.c */
+typedef mwSignedIndex integer;                  /* removed "long" */
+int sfinit_(integer *neqns, integer *nnza, integer *xadj, integer *adjncy,
+            integer *perm, integer *invp, integer *colcnt, integer *nnzl,
+            integer *nsub, integer *nsuper, integer *snode, integer *xsuper,
+            integer *iwsiz, integer *iwork, integer *iflag);
+int symfct_(integer *neqns, integer *adjlen, integer *xadj, integer *adjncy,
+            integer *perm, integer *invp, integer *colcnt, integer *nsuper,
+            integer *xsuper, integer *snode, integer *nofsub, integer *xlindx,
+            integer *lindx, integer *xlnz, integer *iwsiz, integer *iwork,
+            integer *flag__);
+
 #define L_OUT plhs[0]
 #define NPAROUT 1
 
--- sedumi-master/urotorder.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/urotorder.c	2017-06-08 12:37:40.000000000 +1000
@@ -79,7 +79,7 @@ function [u,perm,gjc,g] = urotorder(u,K,
 void rotorder(mwIndex *perm, double *u, mwIndex *gjc, twodouble *g, double *d,
               const double maxusqr, const mwIndex n)
 {
-  mwIndex i,j,k,inz, pivk, m;
+  mwIndex i,j,k,inz, pivk=0, m;
   double *uj, *rowuk;
   double dk,y,nexty, h, uki,ukmax;
   twodouble gi;
@@ -197,7 +197,7 @@ void prpirotorder(mwIndex *perm, double
                   tridouble *g, double *d,
                   const double maxusqr, const mwIndex n)
 {
-  mwIndex i,j,k,inz, pivk, m;
+  mwIndex i,j,k,inz, pivk=0, m;
   double *uj,*ujpi, *rowuk, *rowukpi;
   double dk,y,nexty, h, uki,ukiim,ukmax;
   tridouble gi;
@@ -312,7 +312,7 @@ void mexFunction(const int nlhs, mxArray
 {
   mxArray *myplhs[NPAROUT];
   mwIndex i,j,k, nk, nksqr, lenud, sdplen, gnnz, inz, maxKs,maxKssqr, rgnnz, hgnnz;
-  const double *uOld, *permOld;
+  const double *uOld, *permOld=NULL;
   double *u, *d, *gjcPr, *permPr, *fwork, *fworkpi;
   mwIndex *perm, *gjc;
   double *g, *gk;
--- sedumi-master/vectril.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/vectril.c	2017-06-08 12:37:40.000000000 +1000
@@ -65,7 +65,7 @@
 mwIndex sptriujcT(mwIndex *triujc, const mwIndex *xir, const mwIndex xjc0, const mwIndex xjc1,
               const mwIndex first,const mwIndex n)
 {
-  mwIndex i,j,inz,jnz,jfirst,jlast;
+  mwIndex i,j=0,inz,jnz,jfirst=0,jlast;
 /* ------------------------------------------------------------
    Observe that triu(X(n,:))=[] and hence only use triujc[0:n-2].
    ------------------------------------------------------------ */
@@ -137,7 +137,7 @@ mwIndex sptrilandtriu(mwIndex *yir, doub
                    const double *xpr, const mwIndex xjc0, const mwIndex xjc1,
                    const mwIndex first, const mwIndex n, bool skew)
 {
-  mwIndex i,j,inz,jnz,knz,jfirst,jlast;
+  mwIndex i,j=0,inz,jnz,knz,jfirst=0,jlast;
 /* ------------------------------------------------------------
    Store [tril(X); triu(X,1)'] into y,
    using the column pointers of triu(X,1)' as computed in triujc.
--- sedumi-master/whichcpx.c	2015-06-08 05:24:25.000000000 +1000
+++ SeDuMi_1_3/whichcpx.c	2017-06-08 12:37:40.000000000 +1000
@@ -141,7 +141,7 @@ void mexFunction( int nlhs, mxArray *plh
   int nrhs, const mxArray *prhs[])
 {
   mwIndex i,j,iwsiz, nxcomplex, cpxf;
-  mwIndex *iwork, *lorNL, *rconeNL, *xcomplex;
+  mwIndex *iwork, *lorNL, *rconeNL, *xcomplex=NULL;
   double *myPr;
   const double *xcomplexPr;
   mxArray *MY_FIELD;
