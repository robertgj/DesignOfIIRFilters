--- sdpt3-master/Solver/Mexfun/mexinprod.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexinprod.c	2020-08-12 23:53:37.967840360 +1000
@@ -71,7 +71,7 @@
 
      mwIndex   subs[2];
      mwSize    nsubs=2; 
-     int       mA, nA, m1, n1, m2, n2, j, index;    
+     int       mA, m1, n1, m2, n2, j, index;    
      int       rowidx, colidx, r, k, kstart, kend;
 
 
--- sdpt3-master/Solver/Mexfun/mexmat.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexmat.c	2020-08-13 00:01:04.958979919 +1000
@@ -43,7 +43,7 @@
           jcB[j+1] = count; 
       }   
    } else if (isspA && !isspB) {
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -52,7 +52,7 @@
       }
    } else if (isspA && isspB) {
       count = 0; 
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -101,7 +101,7 @@
           jcB[j+1] = count; 
       }   
    } else if (isspA && !isspB) {
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -111,7 +111,7 @@
       }
    } else if (isspA && isspB) {
       count = 0; 
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -133,9 +133,8 @@
            double *A, int mA, int colidx,  
            double *B, mwIndex *irB, mwIndex *jcB, int isspB)
 
-{  int idx, i, j, r, jn, k, kstart, kend, idxj, j2, count;
-   int t, t2, istart, jstart, jend, rowidx, nsub; 
-   double tmp;  
+{  int idx, i, j, idxj;
+   int t, istart, jstart, jend, rowidx, nsub; 
 
       idx = 0; 
       jstart = 0; jend = 0; jcB[0]=0;  
@@ -164,9 +163,8 @@
            double *B, mwIndex *irB, mwIndex *jcB, int isspB,
            double *AI, double *BI)
 
-{  int idx, i, j, r, jn, k, kstart, kend, idxj, j2, count;
-   int t, t2, istart, jstart, jend, rowidx, nsub; 
-   double tmp;  
+{  int idx, i, j, idxj;
+   int t, istart, jstart, jend, rowidx, nsub; 
 
       idx = 0; 
       jstart = 0; jend = 0; jcB[0]=0;  
@@ -201,13 +199,15 @@
      double   *A, *B, *AI, *BI, *blksize, *Atmp, *AItmp;
      mwIndex  *irA, *jcA, *irB, *jcB;
      int      *cumblksize, *blknnz;
-     int       iscellA, mblk, mA, nA, m1, n1, rowidx, colidx, isspA, isspB;
-     int       iscmpA, iscmpB; 
+     int       iscellA, mA, m1, n1, rowidx, colidx, isspA, isspB;
+     int       iscmpA; 
 
      mwIndex  subs[2];
      mwSize   nsubs=2; 
      int      n, n2, k, nsub, index, numblk, NZmax, r, kstart, kend;
 
+     jcB=0; irB=0; AItmp=0; jcA=0; irA=0;
+     
 /* CHECK FOR PROPER NUMBER OF ARGUMENTS */
 
      if (nrhs < 2){
@@ -218,8 +218,8 @@
 /* CHECK THE DIMENSIONS */
 
      iscellA = mxIsCell(prhs[1]); 
-     if (iscellA) { mA = mxGetM(prhs[1]); nA = mxGetN(prhs[1]); }
-     else         { mA = 1; nA = 1; }
+     if (iscellA) { mA = mxGetM(prhs[1]); }
+     else         { mA = 1; }
      if (mxGetM(prhs[0]) != mA) {
          mexErrMsgTxt("mexsmat: blk and Avec not compatible"); }
 
--- sdpt3-master/Solver/Mexfun/mexnnz.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexnnz.c	2020-08-13 00:20:12.003929618 +1000
@@ -19,7 +19,7 @@
                  int nrhs, const mxArray  *prhs[] )
 
 {    double   *A, *nnz;  
-     mwIndex  *irA, *jcA; 
+     mwIndex  *jcA; 
 
      int      NZmax, m, n, isspA, j, k, jm, nnztmp;
 
@@ -43,7 +43,6 @@
      A = mxGetPr(prhs[0]);
      isspA = mxIsSparse(prhs[0]); 
      if (isspA) { 
-        irA = mxGetIr(prhs[0]);      
         jcA = mxGetJc(prhs[0]);
         NZmax = jcA[n]; 
      }
--- sdpt3-master/Solver/Mexfun/mexProd2.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexProd2.c	2020-08-12 23:50:02.139703333 +1000
@@ -59,7 +59,7 @@
 void product(double *A, double *B, double *P, 
              int m, int n, int p, int type)
 
-{  int  i, j, k, jm, jn, km, kstart, kend;
+{  int  j, k, jm, jn, km, kstart, kend;
    int     istart, iend;
    double  tmp; 
 
@@ -84,7 +84,7 @@
 void product2(double *A, double *B, mwIndex *irB, mwIndex *jcB, 
               double *P, int m, int n, int p, int type)
 
-{  int  i, j, k, r, kstart, kend, istart, iend, jm, rm;
+{  int  j, k, r, kstart, kend, istart, iend, jm, rm;
    double  tmp;
     
       for (j=0; j<p; j++){
@@ -144,6 +144,8 @@
    int  idx;
    double  tmp; 
 
+     jend=0;
+     
      idx = 0;  jcP[0]=0;
      for (l=0; l<numblk; l++) { 
         jstart = cumblk[l]; jend = cumblk[l+1];
@@ -222,10 +224,12 @@
    mwIndex  *irA, *jcA, *irB, *jcB, *irP, *jcP;
    int      *cumblk;
    int       isspA, isspB, m1, n1, m2, n2;
-   int       type, index, numblk, NZmax, cols, i, l;
+   int       type, index, numblk, NZmax, cols, l;
    mwIndex   subs[2];
    mwSize    nsubs=2;
 
+   jcB=0; irB=0; jcA=0; irA=0;
+   
 /* Check for proper number of arguments */
    if (nrhs<3){
       mexErrMsgTxt("mexProd2: requires at least 3 input arguments."); }
--- sdpt3-master/Solver/Mexfun/mexProd2nz.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexProd2nz.c	2020-08-12 23:52:29.473431584 +1000
@@ -63,6 +63,7 @@
 { int  j, k, r, t, rn, jn, jold, kstart, kend, idx, count;
   double  tmp;  
 
+     jn = 0;
      jold = -1; count = 0; 
      for (t=0; t<len; ++t) {
          r = list1[t];
@@ -96,7 +97,7 @@
             double *P, mwIndex *irP, mwIndex *jcP, double *Btmp, 
             int *list1, int *list2, int len)  
 
-{ int  j, k, r, t, rn, jn, jold, kstart, kend, idx, count;
+{ int  j, k, r, t, rn, jold, kstart, kend, idx, count;
   double  tmp;  
 
      jold = -1; count = 0;  
@@ -104,7 +105,6 @@
          r = list1[t];  
          j = list2[t];  
          if (j != jold) {
-            jn = j*n;  
             /***** copy j-th column of sparse B to Btmp *****/ 
             for (k=0; k<n; ++k) { Btmp[k] = 0; }
             kstart = jcB[j];  kend = jcB[j+1];
@@ -139,6 +139,8 @@
    double   *Btmp, *listtmp; 
    int       m1, n1, m2, n2, mlist, nlist, isspA, isspB, k;
 
+   jcA=0; irA=0;
+   
 /* Check for proper number of arguments */
    if (nrhs < 4){
       mexErrMsgTxt("mexProd2nz: requires at least 4 input arguments."); }
--- sdpt3-master/Solver/Mexfun/mexqops.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexqops.c	2020-08-13 00:18:10.670993986 +1000
@@ -85,7 +85,7 @@
 {    double   *blksize, *x, *y, *z, *xtmp, *ytmp; 
      mwIndex  *irx, *jcx, *iry, *jcy; 
      int      *cumblk;
-     int   mblk, options; 
+     int   options; 
 
      int   l, n, k, r, numblk, cols;
 
--- sdpt3-master/Solver/Mexfun/mexschur.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexschur.c	2020-08-13 00:17:19.166445388 +1000
@@ -169,8 +169,8 @@
               mwIndex *nzlistAr, mwIndex *nzlistAc, mwIndex *cumblksize, 
               mwIndex *blkidx, int col, double *schurcol)
 
-{ int    r, ra, ca, rb, cb, l, k, kstart, kend, kstartnew, lstart, lend;
-  int    colcb1, idxrb, idxcb, idx1, idx2, idx3, idx4;
+{ int    ra, ca, rb, cb, l, k, kstart, kend, kstartnew, lstart, lend;
+  int    idxrb, idxcb, idx1, idx2, idx3, idx4;
   int    i, cblk, calk, firstime; 
   double tmp0, tmp1, tmp2, tmp3, tmp4; 
 
@@ -227,8 +227,8 @@
                mwIndex *nzlistAr, mwIndex *nzlistAc, mwIndex *cumblksize, 
                mwIndex *blkidx, int col, double *schurcol)
 
-{ int    r, ra, ca, rb, cb, l, k, kstart, kend, kstartnew, lstart, lend;
-  int    colcb1, idxrb, idxcb, idx1, idx2, idx3, idx4; 
+{ int    ra, ca, rb, cb, l, k, kstart, kend, kstartnew, lstart, lend;
+  int    idxrb, idxcb, idx1, idx2, idx3, idx4; 
   int    i, cblk, calk, firstime;
   double tmp0, tmp1, tmp2, tmp3, tmp4;
   double hlf=0.5;  
@@ -291,9 +291,10 @@
      mwIndex  subs[2];
      mwSize   nsubs=2; 
      int      index, colend, type, isspU, isspV, numblk, nzP, existP; 
-     int      len, row, col, nU, nV, n, m, m1, idx1, idx2, l, k, nsub, n1, n2, opt, opt2;
+     int      len, row, col, nU, nV, n, m, m1, idx1, idx2, l, k, nsub, n1, n2, opt;
      int      kstart, kend, rb, cb, cblk, colcb, count; 
-     double   tmp; 
+
+     opt=0; Utmp=0; Vtmp=0; nzlistAc=0; nzlistAr=0; blknnz=0; cumblksize=0; blkidx=0; nzP=0; jcP=0; irP=0; jcV=0; irV=0;
 
 /* CHECK THE DIMENSIONS */
 
@@ -363,9 +364,10 @@
 /************************************
 * output 
 ************************************/
-
+   if (nlhs>=1) {
     plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL); 
     nzschur = mxGetPr(plhs[0]); 
+    }
     if (nlhs==2) {
        nzP = (int) (0.2*m*m+5); 
        plhs[1] = mxCreateSparse(m,colend,nzP,mxREAL); 
@@ -444,7 +446,7 @@
 	}
         for (row=0; row<=col; row++) {
 	    if (schurcol[row] != 0) {
-	       if (count<nzP && nlhs==2) { jcP[col+1]=count+1; irP[count]=row; P[count]=1; }
+	       if (nlhs==2 && count<nzP) { jcP[col+1]=count+1; irP[count]=row; P[count]=1; }
 	       count++; 
    	       idx1 = permA[row]+colm[col]; 
                idx2 = permA[col]+colm[row]; 
@@ -454,11 +456,13 @@
 	}
     }
     
+    if (nlhs>=1) {
     nzschur[0] = count;
+    }
 
     mxFree(blksize); mxFree(nzlistAi); mxFree(nzlistAj); 
     mxFree(permA);   mxFree(idxstart); mxFree(schurcol); 
-    if (isspU) { 
+    if (isspU && isspV) { 
        mxFree(Utmp);     mxFree(Vtmp); 
        mxFree(nzlistAc); mxFree(nzlistAr); 
        mxFree(blknnz); mxFree(cumblksize); mxFree(blkidx); 
--- sdpt3-master/Solver/Mexfun/mexschurfun.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexschurfun.c	2020-08-13 00:21:49.413075139 +1000
@@ -18,7 +18,9 @@
   mwIndex  *irX, *jcX, *irY, *jcY; 
   int       n, isspX, isspY, j, jn, k, kstart, kend, r, kstart2, kend2; 
   int       options, scalarY; 
-  double    tmp, tmp2, alpha;
+  double    alpha;
+
+  alpha=0; scalarY=0; jcY=0; irY=0; jcX=0; irX=0;
 
   if(nrhs < 2)
     mexErrMsgTxt("mexschurfun: requires at least 2 input arguments.");
@@ -41,7 +43,7 @@
      jcY = mxGetJc(prhs[1]);
   } 
   if (nrhs == 2) { 
-     if ((mxGetM(prhs[1]) == n) & (mxGetN(prhs[1]) == n)) {
+     if ((mxGetM(prhs[1]) == n) && (mxGetN(prhs[1]) == n)) {
        options = 2; 
      } else {
        options = 1; 
@@ -50,10 +52,10 @@
      options = (int) (*mxGetPr(prhs[2])); 
   }
   if (options == 1 || options == 3) {
-     if ((mxGetN(prhs[1]) != 1) & (mxGetM(prhs[1]) != 1)) {
+     if ((mxGetN(prhs[1]) != 1) && (mxGetM(prhs[1]) != 1)) {
         mexErrMsgTxt("mexschurfun: Y should be a vector."); }
   } else {
-     if ((mxGetN(prhs[1]) == 1) & (mxGetM(prhs[1]) == 1)) {
+     if ((mxGetN(prhs[1]) == 1) && (mxGetM(prhs[1]) == 1)) {
 	scalarY = 1; 
         alpha = Y[0]; 
      } else {
@@ -95,19 +97,19 @@
 	   }
 	}
      } else {
-        if (isspX & !isspY) {
+        if (isspX && !isspY) {
            for (j=0; j<n; j++) {
 	      kstart = jcX[j]; kend = jcX[j+1]; jn = j*n; 
               for (k=kstart; k<kend; k++) { 
 	         r = irX[k];
                  X[k] += Y[r+jn]; }
 	   }
-        } else if (!isspX & !isspY) { 
+        } else if (!isspX && !isspY) { 
            for (j=0; j<n; j++) { 
               jn = j*n;
               for (k=0; k<n; k++) { X[k+jn] += Y[k+jn]; }
 	   }
-	} else if (!isspX & isspY) { 
+	} else if (!isspX && isspY) { 
            for (j=0; j<n; j++) {
 	      kstart = jcY[j]; kend = jcY[j+1]; jn = j*n; 
               for (k=kstart; k<kend; k++) { 
--- sdpt3-master/Solver/Mexfun/mexskron.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexskron.c	2020-08-13 00:19:25.297339345 +1000
@@ -125,7 +125,7 @@
 {    mxArray  *blk_cell_pr;
      mxArray  *tmparr[3];
      double   *A,  *B,  *blksizetmp, *P, *Q, *V; 
-     double   *ii, *jj, *vv, *vvtmp, *x1, *y1, *x2, *y2; 
+     double   *vvtmp, *x1, *y1, *x2, *y2; 
      mwIndex  *irA, *jcA, *irB, *jcB, *irV, *jcV;
      int      *blksize, *blksize2, *cumblksize, *blksize4;
      int       isspA, isspB, sym;
--- sdpt3-master/Solver/Mexfun/mexsmat.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexsmat.c	2020-08-13 00:06:08.740318609 +1000
@@ -58,7 +58,7 @@
    double tmp;  
    double hf=0.5; 
    
-   if (!isspA & !isspB) { 
+   if (!isspA && !isspB) { 
       idx = colidx*mA; 
       for (j=0; j<n; j++) { 
           jn = j*n; 
@@ -68,8 +68,8 @@
           B[j+jn] = A[idx];
           idx++; 
       }
-   } else if (isspA & !isspB) {      
-      j2 = 0; idxj = 0; 
+   } else if (isspA && !isspB) {      
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -77,7 +77,7 @@
           if (i < j) { B[i+j*n] = ir2*A[k]; }
           else       { B[i+j*n] = A[k]; }
       }
-   } else if (!isspA & isspB) { 
+   } else if (!isspA && isspB) { 
       idx = colidx*mA; 
       count = 0; 
       for (j=0; j<n; j++) { 
@@ -91,9 +91,9 @@
           idx++; 
           jcB[j+1] = count; 
       }   
-   } else if (isspA & isspB) { 
+   } else if (isspA && isspB) { 
       count = 0; 
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -118,9 +118,8 @@
            int mA, int colidx, 
            double *B, mwIndex *irB, mwIndex *jcB, int isspB)
 
-{  int idx, i, j, r, jn, k, kstart, kend, idxj, j2, count;
+{  int idx, i, j, r, k, kstart, kend, idxj, j2, count;
    int t, t2, istart, jstart, jend, rowidx; 
-   double tmp;  
    double hf=0.5; 
 
    if (!isspA) { 
@@ -143,7 +142,7 @@
    } else {
       jstart = 0; jend = cumblksize[1]; t2 = 0; 
       kstart = jcA[colidx]; kend = jcA[colidx+1]; 
-      count  = 0; j2 = 0; idxj = 0; 
+      i = 0; count  = 0; j2 = 0; idxj = 0; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
           for (t=t2; t<numblk; t++) { if (r-blknnz[t+1]<0) {break;} } 
@@ -179,7 +178,7 @@
    double tmp, tmp2;  
    double hf=0.5; 
    
-   if (!isspA & !isspB) { 
+   if (!isspA && !isspB) { 
       idx = colidx*mA; 
       for (j=0; j<n; j++) { 
           jn = j*n; 
@@ -191,8 +190,8 @@
           BI[j+jn] = AI[idx];
           idx++; 
       }
-   } else if (isspA & !isspB) {      
-      j2 = 0; idxj = 0; 
+   } else if (isspA && !isspB) {      
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -200,7 +199,7 @@
           if (i < j) { ind = i+j*n; B[ind] = ir2*A[k]; BI[ind] = ir2*AI[k]; }
           else       { ind = i+j*n; B[ind] = A[k];     BI[ind] = AI[k];}
       }
-   } else if (!isspA & isspB) { 
+   } else if (!isspA && isspB) { 
       idx = colidx*mA; 
       count = 0; 
       for (j=0; j<n; j++) { 
@@ -221,9 +220,9 @@
           idx++; 
           jcB[j+1] = count; 
       }   
-   } else if (isspA & isspB) { 
+   } else if (isspA && isspB) { 
       count = 0; 
-      j2 = 0; idxj = 0; 
+      i = 0; j2 = 0; idxj = 0; 
       kstart = jcA[colidx];  kend = jcA[colidx+1]; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
@@ -254,9 +253,8 @@
            double *B, mwIndex *irB, mwIndex *jcB, int isspB,
            double *AI, double *BI)
 
-{  int  idx, i, j, r, jn, k, kstart, kend, idxj, j2, count;
+{  int  idx, i, j, r, k, kstart, kend, idxj, j2, count;
    int  t, t2, istart, jstart, jend, rowidx; 
-   double tmp;  
    double hf=0.5; 
 
    if (!isspA) { 
@@ -284,7 +282,7 @@
    } else {
       jstart = 0; jend = cumblksize[1]; t2 = 0; 
       kstart = jcA[colidx]; kend = jcA[colidx+1]; 
-      count  = 0; j2 = 0; idxj = 0; 
+      i = 0; count  = 0; j2 = 0; idxj = 0; 
       for (k=kstart; k<kend; k++) { 
           r = irA[k];
           for (t=t2; t<numblk; t++) { if (r-blknnz[t+1]<0) {break;} } 
@@ -320,7 +318,7 @@
      double   *A,  *B,  *blksize, *AI, *BI;
      mwIndex  *irA, *jcA, *irB, *jcB;
      int      *cumblksize, *blknnz;
-     int       mblk, mA, nA, m1, n1, rowidx, colidx, isspA, isspB;
+     int       mA, m1, n1, rowidx, colidx, isspA, isspB;
      int       iscellA, iscmpA; 
 
      mwIndex  subs[2];
@@ -328,6 +326,8 @@
      int      n, n2, k, nsub, index, numblk, NZmax;
      double   ir2=1/sqrt(2); 
 
+     irA=0; jcA=0; irB=0; jcB=0;
+     
 /* CHECK FOR PROPER NUMBER OF ARGUMENTS */
 
      if (nrhs < 2){
@@ -338,8 +338,8 @@
 /* CHECK THE DIMENSIONS */
 
      iscellA = mxIsCell(prhs[1]); 
-     if (iscellA) { mA = mxGetM(prhs[1]); nA = mxGetN(prhs[1]); }
-     else         { mA = 1; nA = 1; }
+     if (iscellA) { mA = mxGetM(prhs[1]); }
+     else         { mA = 1; }
      if (mxGetM(prhs[0]) != mA) {
          mexErrMsgTxt("mexsmat: blk and Avec not compatible"); }
 
--- sdpt3-master/Solver/Mexfun/mexsvec.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mexsvec.c	2020-08-13 00:08:53.411876021 +1000
@@ -28,7 +28,7 @@
 
 {  int idx, i, j, jn, k, kstart, kend, idxj; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       for (j=0; j<n; j++) { 
           jn = j*n; 
@@ -38,7 +38,7 @@
           B[idx] = A[j+jn]; 
           idx++; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       idxj = 0; 
       for (j=0; j<n; j++) { 
@@ -53,7 +53,7 @@
           idx++; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) {
+   } else if (!isspB && isspA) {
       idx = 0; 
       for (j=0; j<n; j++) { 
           idx += j; 
@@ -67,7 +67,7 @@
              if (i == j) {  B[idx+i] = A[k]; }        
 	  }
       }
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       idxj = 0; 
       for (j=0; j<n; j++) { 
@@ -102,7 +102,7 @@
 {  int idx, i, j, jn, l, jstart, jend, istart;
    int rowidx, idxj, k, kstart, kend; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -117,7 +117,7 @@
               idx++;    }
           jstart = jend; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -139,7 +139,7 @@
           jstart = jend; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) { 
+   } else if (!isspB && isspA) { 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
   	  jend = cumblksize[l+1];  
@@ -159,7 +159,7 @@
           }
           jstart = jend; 
       }  
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -197,9 +197,9 @@
            double *A, mwIndex *irA, mwIndex *jcA, int isspA, 
            double *B, mwIndex *irB, mwIndex *jcB, int isspB) 
 
-{  int idx, rowidx, i, j, jn, k, kstart, kend; 
+{  int idx, rowidx, i, j, k, kstart, kend; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       for (i=0; i<n; i++) { 
           for (j=0; j<i; j++) { 
@@ -208,7 +208,7 @@
           B[idx] = A[j+j*n]; 
           idx++; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       rowidx = 0; 
       for (i=0; i<n; i++) { 
@@ -222,7 +222,7 @@
           idx++; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) {
+   } else if (!isspB && isspA) {
       for (j=0; j<n; j++) { 
           kstart = jcA[j]; kend = jcA[j+1]; 
           for (k=kstart; k<kend; k++) { 
@@ -235,7 +235,7 @@
 		  B[j+idx] = A[k]; }        
 	  }
       }
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       for (j=0; j<n; j++) { 
           kstart = jcA[j];  kend = jcA[j+1];
@@ -326,7 +326,7 @@
 
 {  int idx, i, j, jn, k, kstart, kend, idxj; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       for (j=0; j<n; j++) { 
           jn = j*n; 
@@ -338,7 +338,7 @@
           BI[idx] = AI[j+jn]; 
           idx++; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       idxj = 0; 
       for (j=0; j<n; j++) { 
@@ -355,7 +355,7 @@
           idx++; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) {
+   } else if (!isspB && isspA) {
       idx = 0; 
       for (j=0; j<n; j++) { 
           idx += j; 
@@ -370,7 +370,7 @@
              if (i == j) {  B[idx+i] = A[k]; BI[idx+i] = AI[k];}        
 	  }
       }
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       idxj = 0; 
       for (j=0; j<n; j++) { 
@@ -409,7 +409,7 @@
 {  int idx, i, j, jn, l, jstart, jend, istart;
    int rowidx, idxj, k, kstart, kend; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -426,7 +426,7 @@
               idx++;    }
           jstart = jend; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -450,7 +450,7 @@
           jstart = jend; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) { 
+   } else if (!isspB && isspA) { 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
   	  jend = cumblksize[l+1];  
@@ -471,7 +471,7 @@
           }
           jstart = jend; 
       }  
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       jstart = 0; jend = 0; 
       for (l=0; l<numblk; l++) { 
@@ -513,9 +513,9 @@
            double *B, mwIndex *irB, mwIndex *jcB, int isspB,
            double *AI, double *BI) 
 
-{  int idx, rowidx, i, j, jn, k, kstart, kend; 
+{  int idx, rowidx, i, j, k, kstart, kend; 
    
-   if (!isspB & !isspA) { 
+   if (!isspB && !isspA) { 
       idx = 0; 
       for (i=0; i<n; i++) { 
           for (j=0; j<i; j++) { 
@@ -526,7 +526,7 @@
           BI[idx] = AI[j+j*n]; 
           idx++; 
       }
-   } else if (isspB & !isspA) { 
+   } else if (isspB && !isspA) { 
       idx = 0; 
       rowidx = 0; 
       for (i=0; i<n; i++) { 
@@ -542,7 +542,7 @@
           idx++; 
       }  
       jcB[1] = idx;  
-   } else if (!isspB & isspA) {
+   } else if (!isspB && isspA) {
       for (j=0; j<n; j++) { 
           kstart = jcA[j]; kend = jcA[j+1]; 
           for (k=kstart; k<kend; k++) { 
@@ -558,7 +558,7 @@
 	       }        
 	  }
       }
-   } else if (isspB & isspA) {
+   } else if (isspB && isspA) {
       idx = 0; 
       for (j=0; j<n; j++) { 
           kstart = jcA[j];  kend = jcA[j+1];
@@ -595,6 +595,7 @@
 {  int idx, i, i1, j, l, jstart, jend, istart;
    int rowidx, idx2, idx3, k, kstart, kend; 
    
+   i1 = 0;
    if (!isspB) { 
       for (l=0; l<numblk; l++) { 
 	  jstart = cumblksize[l]; jend = cumblksize[l+1];  
@@ -664,6 +665,8 @@
      int      m, n, n2, nsub, k, index, numblk, NZmax, type; 
      double   r2; 
 
+     irA=0; jcA=0; irB=0; jcB=0;
+     
 /* CHECK FOR PROPER NUMBER OF ARGUMENTS */
 
    if (nrhs < 2){
@@ -711,7 +714,7 @@
        NZmax = n2; 
     }
     if (iscmpA) { AI = mxGetPi(prhs[1]); }
-    if ((numblk > 1) & (!isspA)) {
+    if ((numblk > 1) && (!isspA)) {
        mexErrMsgTxt("mexsvec: matrix must be sparse for numblk > 1"); }
     if (nrhs > 2) { 
        if (mxGetM(prhs[2])>1) { isspB = (int)*mxGetPr(prhs[2]); }
--- sdpt3-master/Solver/Mexfun/mextriangsp.c	2020-01-30 16:27:19.000000000 +1100
+++ sdpt3-master.new/Solver/Mexfun/mextriangsp.c	2020-08-13 00:23:22.237260849 +1000
@@ -76,6 +76,8 @@
    int         k, kend, options;   
    double     *x, *b, *btmp;
 
+   irU=0; jcU=0;
+   
    if (nrhs < 2) {
       mexErrMsgTxt("mextriangsp requires 2 input arguments."); }
    if (nlhs > 1) {
