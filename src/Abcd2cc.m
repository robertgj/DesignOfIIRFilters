function Abcd2cc(A,b,c,d,bits,name)
% Abcd2cc(A,b,c,d,bits,name)
% Generate C++ code for a state variable filter [A,b,c,d] with bits 
% fixed-point precision. c and d can represent block filter outputs.

% Copyright (C) 2017-2025 Robert G. Jenssen
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation
% files (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions: The above copyright notice and
% this permission notice shall be included in all copies or substantial
% portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
% IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
% CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
% TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
% SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

if nargin ~= 6
  print_usage("Abcd2cc(A,b,c,d,bits,name)");
endif

%
% Output scale factor
%
scale = 2^(bits-1);

% Find block processing length
[mblock , n]=size(d);

%
% Open file
%
fid=fopen(strcat(name,".cc"),"w");

%
% Banner
%
fprintf(fid,"// Generated by Abcd2cc.m for the %s filter.",name);
fprintf(fid,"\n// Compile with :");
fprintf(fid,"\n//\t\"mkoctfile(\"%s.cc\",\"-D USING_OCTAVE\")\"",name);
fprintf(fid,"\n//");
fprintf(fid,"\n// This file is linked with Octave and so is a derivative");
fprintf(fid,"\n// work and is subject to the GPLv3 or later. Accordingly");
fprintf(fid,"\n// the following notice applies:");
fprintf(fid,"\n//");
fprintf(fid,"\n// This program is free software; you can redistribute it");
fprintf(fid,"\n// and/or modify it underthe terms of the GNU General Public");
fprintf(fid,"\n// License as published by the Free Software Foundation;");
fprintf(fid,"\n// either version 3 of the License, or (at your option)");
fprintf(fid,"\n// any later version. This program is distributed in the");
fprintf(fid,"\n// hope that it will be useful, but WITHOUT ANY WARRANTY;");
fprintf(fid,"\n// without even the implied warranty of MERCHANTABILITY");
fprintf(fid,"\n// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU");
fprintf(fid,"\n// General Public License for more details. You should");
fprintf(fid,"\n// have received a copy of the GNU General Public License");
fprintf(fid,"\n// along with this program. If not, see:");
fprintf(fid,"\n// <http://www.gnu.org/licenses/>.");

%
% For mkoctfile
%
fprintf(fid,"\n\n#if defined(USING_OCTAVE)");

%
% Octfile definitions
% 
fprintf(fid,"\n\n#include <math.h>");
fprintf(fid,"\n\n#include <octave/oct.h>");

%
% Forward definitions
%
fprintf(fid,"\n\ntypedef double WORD;");
fprintf(fid,"\ntypedef double MAC;");
fprintf(fid,"\n\nvoid filter_%s_init(void);",name);
fprintf(fid,"\nvoid filter_%s(const WORD *, WORD *);",name);

%
% Octfile function
%
fprintf(fid,
        sprintf("\n\nDEFUN_DLD(%s, args, nargout,\"y=%s(u)\")",
                name,name));
fprintf(fid,"\n{");
% Sanity check
fprintf(fid,"\n\t// Sanity check");
fprintf(fid,"\n\tif ((args.length() != 1) || (nargout != 1))")
fprintf(fid,"\n\t{");
fprintf(fid,"\n\t\tprint_usage();");
fprintf(fid,"\n\t\treturn octave_value();");
fprintf(fid,"\n\t}");
% Input argument
fprintf(fid,"\n\n\t// Input argument");
fprintf(fid,"\n\tint64_t N = args(0).length();");
fprintf(fid,"\n\tColumnVector u = args(0).vector_value();");
% Output argument
fprintf(fid,"\n\n\t// Output argument");
fprintf(fid,"\n\tColumnVector y(N);");
% Call the filter
fprintf(fid,"\n\n\t// Call the filter");
fprintf(fid,"\n\tfilter_%s_init();",name);
fprintf(fid,"\n\tconst int64_t mblock=%d;",mblock);
fprintf(fid,"\n\tfor(int64_t k=0; (k+mblock)<N; k+=mblock)");
fprintf(fid,"\n\t\t{");
fprintf(fid,"\n\t\t\tWORD ublock[mblock];");  
fprintf(fid,"\n\t\t\tWORD yblock[mblock];");
fprintf(fid,"\n\t\t\tfor(int64_t l=0; l<mblock; l++)");
fprintf(fid,"\n\t\t\t\t{");
fprintf(fid,"\n\t\t\t\t\tublock[l] = u(k+l);");  
fprintf(fid,"\n\t\t\t\t}");
fprintf(fid,"\n\t\t\tfilter_%s(ublock, yblock);", name);
fprintf(fid,"\n\t\t\tfor(int64_t l=0; l<mblock; l++)");
fprintf(fid,"\n\t\t\t\t{");
fprintf(fid,"\n\t\t\t\t\ty(k+l) = yblock[l];");    
fprintf(fid,"\n\t\t\t\t}");
fprintf(fid,"\n\t\t}");
% Return
fprintf(fid,"\n\n\t// Done");
fprintf(fid,"\n\treturn octave_value(y);");
fprintf(fid,"\n}");

%
% A routine to scale the accumulator output
%
fprintf(fid,"\n\nstatic WORD filter_scale_output(MAC mac)");
fprintf(fid,"\n{");
fprintf(fid,"\n\tstatic const double scale = %f;",scale);
fprintf(fid,"\n\treturn round(mac/scale);");
fprintf(fid,"\n}");

%
% Using mkoctfile
%
fprintf(fid,"\n\n#endif // USING_OCTAVE\n");

%
% Print the filter states
%
[m , nstate]=size(A);
for x=1:nstate
  fprintf(fid,"\nstatic WORD %s_x_%d;",name,x);
endfor

%
% A routine to initialise the static stage
%
fprintf(fid,"\n\nvoid filter_%s_init(void)",name);
fprintf(fid,"\n{");
for x=1:nstate
  fprintf(fid,"\n\t%s_x_%d = 0;",name,x);
endfor
fprintf(fid,"\n}");

%
% Print the function
%
fprintf(fid,"\n\nvoid filter_%s(const WORD *u, WORD *y)",name);
fprintf(fid,"\n{");

%
% Truncate coefficients
%
A=round(A*scale);
b=round(b*scale);
c=round(c*scale);
d=round(d*scale);

%
% Print the coefficients
%
[m , n]=size(A);
for x=1:m
  for y=1:n
    if A(x,y) ~= 0
      fprintf(fid,"\n\tstatic const WORD A_%d_%d = %6d;", x,y,A(x,y));
    endif
  endfor
endfor
[m , n]=size(b);
for x=1:m
  for y=1:n
    if b(x,y) ~= 0
      fprintf(fid,"\n\tstatic const WORD b_%d_%d = %6d;", x,y,b(x,y));
    endif
  endfor
endfor
[m , n]=size(c);
for x=1:m
  for y=1:n
    if c(x,y) ~= 0
      fprintf(fid,"\n\tstatic const WORD c_%d_%d = %6d;", x,y,c(x,y));
    endif
  endfor
endfor
[mblock , n]=size(d);
for x=1:mblock
  for y=1:mblock
    if d(x,y) ~= 0
      fprintf(fid,"\n\tstatic const WORD d_%d_%d = %6d;", x,y,d(x,y));
    endif
  endfor
endfor

%
% Print local variables
%
for x=1:nstate
  fprintf(fid,"\n\tWORD x_%d_tmp;",x);
end
fprintf(fid,"\n\tMAC mac;");

%
% Make the outputs, y
%
for x=1:mblock
  fprintf(fid,"\n\n\t// Calculate the y[%d] output",x-1);
  fprintf(fid,"\n\tmac = 0;");
  for y=1:nstate
    if c(x,y)  ~= 0
      fprintf(fid,"\n\tmac += c_%d_%d*%s_x_%d;",x,y,name,y);
    endif
  endfor
  for y=1:mblock
    if d(x,y) ~= 0
      fprintf(fid,"\n\tmac += d_%d_%d*u[%d];", x, y, y-1);
    endif
  endfor
  fprintf(fid,"\n\ty[%d] = filter_scale_output(mac);",x-1);
endfor

%
% Make the state updates, x
%
fprintf(fid,"\n\n\t// Make temporary variables");
for x=1:nstate
  fprintf(fid,"\n\tx_%d_tmp = %s_x_%d;",x,name,x);
endfor
for x=1:nstate
  fprintf(fid,"\n\n\t// Update state %s_x_%d",name,x);
  fprintf(fid,"\n\tmac = 0;");
  for y=1:nstate
    if A(x,y) ~= 0
      fprintf(fid,"\n\tmac += A_%d_%d*x_%d_tmp;",x,y,y);
    endif
  endfor
  for y=1:mblock
    if b(x,y) ~= 0
      fprintf(fid,"\n\tmac += b_%d_%d*u[%d];",x,y,y-1);
    endif
  endfor
  fprintf(fid,"\n\t%s_x_%d = filter_scale_output(mac);",name,x);
endfor

%
% Done
%
fprintf(fid,"\n}\n");
fclose(fid);

endfunction
