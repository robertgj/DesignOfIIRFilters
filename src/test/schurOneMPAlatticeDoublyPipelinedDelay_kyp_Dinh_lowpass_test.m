% schurOneMPAlatticeDoublyPipelinedDelay_kyp_Dinh_lowpass_test.m
% Copyright (C) 2024-2025 Robert G. Jenssen
%
% Design a Schur one-multiplier all-pass filter with the Finsler
% transformation of the KYP lemma and the BMI convex over-approximation
% of Dinh et al.. See: "Combining Convexâ€“Concave Decompositions and
% Linearization Approaches for Solving BMIs, With Application to Static Output
% Feedback", July, 2011. Available at:
%   https://set.kuleuven.be/optec/Software/softwarefiles/bmipaper
%
% N    rows(A)     rows(F)
%    2*((N+DD)+2)  3*rows(A)+3
% 4      18          57
% 5      22          69
% 6      26          81
% 7      30          93
% 8      34         105

test_common;

strf="schurOneMPAlatticeDoublyPipelinedDelay_kyp_Dinh_lowpass_test";
delete(strcat(strf,".diary"));
delete(strcat(strf,".diary.tmp"));
eval(sprintf("diary %s.diary.tmp",strf));

tic;

schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_start;

use_best_k_found=true
use_hessEsq=true
use_updateHessEsqBfgs=false
use_scs=false
use_sedumi=false
maxiter_kyp=50;

if use_best_k_found
  maxiter_succ_approx=0;
  printf("\n\nUsing best k found!\n\n");
  % 10*log10(min(Asq))(pass)=-0.117677,10*log10(max(Asq))(stop)=-43.1477
  Esq=2.87216e-06
  gradEsq = [ -5.08411e-05, -3.75344e-05, 2.85963e-05, 2.66296e-05, ... 
              3.8567e-06 ];
  diagHessEsq = [ 0.0192588, 0.0268762, 0.0247513, 0.0274024, ... 
                  0.0298875 ];
  k0 = [  -0.5887890122,   0.3794825489,   0.2077136416,   0.0867433777, ... 
           0.0216280074 ];
  k = [   -0.5590415658,   0.4177035965,   0.2281384912,   0.0940832984, ... 
           0.0193019506 ];
  list_norm_dk = [ 0.0037716947, 0.0030743639, 0.0025795559, 0.0022640922, ... 
       0.0022951296, 0.0022103629, 0.0019253921, 0.0020468784, ... 
       0.0019423065, 0.0018972180, 0.0018544873, 0.0018136253, ... 
       0.0017683382, 0.0017853431, 0.0017283997, 0.0016692767, ... 
       0.0015466095, 0.0017964974, 0.0018431064, 0.0015246307, ... 
       0.0014774086, 0.0012597561, 0.0010720770, 0.0010161090, ... 
       0.0012803778, 0.0007547298, 0.0003929319, 0.0003518398, ... 
       0.0003619134, 0.0007271066, 0.0004447680, 0.0005775120, ... 
       0.0002523282, 0.0008516390, 0.0002952175, 0.0002747722, ... 
       0.0003005669, 0.0002334231, 0.0002165639, 0.0001992059, ... 
       0.0002192653, 0.0002241808, 0.0002927923, 0.0003265457, ... 
       0.0001882371, 0.0001417746, 0.0001253047, 0.0001199729, ... 
       0.0002560688, 0.0001914703 ]';
  list_Esq = [ 0.0000361514, 0.0000313399, 0.0000274966, 0.0000243763, ... 
       0.0000215886, 0.0000191677, 0.0000172217, 0.0000153731, ... 
       0.0000137733, 0.0000123595, 0.0000111086, 0.0000100019, ... 
       0.0000090264, 0.0000081948, 0.0000074209, 0.0000067416, ... 
       0.0000061723, 0.0000055824, 0.0000050607, 0.0000046650, ... 
       0.0000043298, 0.0000040737, 0.0000038829, 0.0000037172, ... 
       0.0000035251, 0.0000034226, 0.0000033777, 0.0000033406, ... 
       0.0000033005, 0.0000032166, 0.0000031727, 0.0000031137, ... 
       0.0000031024, 0.0000030212, 0.0000030052, 0.0000029866, ... 
       0.0000029638, 0.0000029528, 0.0000029409, 0.0000029316, ... 
       0.0000029166, 0.0000029045, 0.0000028831, 0.0000028918, ... 
       0.0000028958, 0.0000028975, 0.0000028916, 0.0000028903, ... 
       0.0000028714, 0.0000028722 ]';
  list_Asq_min = [ 0.8866441061, 0.8933427092, 0.8991733482, 0.9042614069, ... 
       0.9092009774, 0.9138199095, 0.9177050803, 0.9217525435, ... 
       0.9254835749, 0.9290227966, 0.9323851889, 0.9355825273, ... 
       0.9386127972, 0.9414464026, 0.9442356054, 0.9468888584, ... 
       0.9492875301, 0.9520386787, 0.9547566677, 0.9569074289, ... 
       0.9589581621, 0.9606429102, 0.9619166425, 0.9632482245, ... 
       0.9648725674, 0.9657837802, 0.9662264398, 0.9666216452, ... 
       0.9670142948, 0.9678610218, 0.9683721837, 0.9690285755, ... 
       0.9692446537, 0.9701265793, 0.9704311855, 0.9707264289, ... 
       0.9710493359, 0.9712866400, 0.9715120191, 0.9717139971, ... 
       0.9719390286, 0.9721767150, 0.9724566083, 0.9726174898, ... 
       0.9727190418, 0.9727963699, 0.9728693926, 0.9729602690, ... 
       0.9731122920, 0.9732677397 ]';
  list_Asq_max = [ 0.0000360240, 0.0000393790, 0.0000453343, 0.0000460778, ... 
       0.0000495466, 0.0000517140, 0.0000470196, 0.0000484404, ... 
       0.0000475494, 0.0000469034, 0.0000476285, 0.0000482644, ... 
       0.0000487650, 0.0000427720, 0.0000417302, 0.0000417835, ... 
       0.0000422915, 0.0000430142, 0.0000422705, 0.0000450609, ... 
       0.0000460495, 0.0000474544, 0.0000484150, 0.0000483075, ... 
       0.0000488361, 0.0000494645, 0.0000489332, 0.0000484032, ... 
       0.0000492130, 0.0000503528, 0.0000498088, 0.0000508923, ... 
       0.0000498088, 0.0000514168, 0.0000506939, 0.0000504288, ... 
       0.0000505919, 0.0000501338, 0.0000499679, 0.0000497475, ... 
       0.0000499694, 0.0000498636, 0.0000503964, 0.0000489718, ... 
       0.0000483066, 0.0000479396, 0.0000482466, 0.0000480549, ... 
       0.0000490245, 0.0000484423 ]';
else
  maxiter_succ_approx=maxiter_kyp;
endif

for m=1:maxiter_succ_approx,

  % Constant part of the pass band constraint matrix
  P_p=zeros(size(P_p));
  Q_p=zeros(size(Q_p));
  Lzm_p=kron(Phi,P_p)+kron(Psi_p,Q_p);
  Uzm_p=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_p,D,-1]];
  Vzm_p=[[XYZ_p,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VplusUzm_p=(Uzm_p+(Vzm_p'))/sqrt(2);
  UminusVzm_p=(Uzm_p-(Vzm_p'))/sqrt(2);
  Fzm_p=[[[[Lzm_p,zeros(2*n,2)]; ...
           [zeros(1,2*n),-Esq_p,0]; ...
           [zeros(1,(2*n)+1),1]],(VplusUzm_p')]; ...
         [VplusUzm_p,-eye(n+1)]] - ...
        [[(UminusVzm_p')*UminusVzm_p,zeros(2*(n+1),n+1)]; ...
         [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Linear part of the pass band constraint matrix
  gLzm_p=kron(Phi,dP_p)+kron(Psi_p,dQ_p);
  gUzm_p=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_p=[[dXYZ_p,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVplusUzm_p=(gUzm_p+(gVzm_p'))/sqrt(2);
  gUminusVzm_p=(gUzm_p-(gVzm_p'))/sqrt(2);
  gFzm_p=[[[[gLzm_p,zeros(2*n,2)]; ...
            [zeros(1,2*n),-dEsq_p,0]; ...
            [zeros(1,(2*n)+1),0]],(gVplusUzm_p')]; ...
          [gVplusUzm_p,zeros(n+1)]] - ...
         [[(gUminusVzm_p')*UminusVzm_p,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]] - ...
         [[(UminusVzm_p')*gUminusVzm_p,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Construct pass band constraint matrix
  bFzm_p=Fzm_p+gFzm_p;

  % Constant part of the stop band constraint matrix
  P_s=zeros(size(P_s));
  Q_s=zeros(size(Q_s));
  Lzm_s=kron(Phi,P_s)+kron(Psi_s,Q_s);
  Uzm_s=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_s,D,-1]];
  Vzm_s=[[XYZ_s,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VplusUzm_s=(Uzm_s+(Vzm_s'))/sqrt(2);
  UminusVzm_s=(Uzm_s-(Vzm_s'))/sqrt(2);
  Fzm_s=[[[[Lzm_s,zeros(2*n,2)]; ...
           [zeros(1,2*n),-Esq_s,0]; ...
           [zeros(1,(2*n)+1),1]],(VplusUzm_s')]; ...
         [VplusUzm_s,-eye(n+1)]] - ...
        [[(UminusVzm_s')*UminusVzm_s,zeros(2*(n+1),n+1)]; ...
         [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Linear part of the stop band constraint matrix
  gLzm_s=kron(Phi,dP_s)+kron(Psi_s,dQ_s);
  gUzm_s=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_s=[[dXYZ_s,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVplusUzm_s=(gUzm_s+(gVzm_s'))/sqrt(2);
  gUminusVzm_s=(gUzm_s-(gVzm_s'))/sqrt(2);
  gFzm_s=[[[[gLzm_s,zeros(2*n,2)]; ...
            [zeros(1,2*n),-dEsq_s,0]; ...
            [zeros(1,(2*n)+1),0]],(gVplusUzm_s')]; ...
          [gVplusUzm_s,zeros(n+1)]] - ...
         [[(gUminusVzm_s')*UminusVzm_s,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]] - ...
         [[(UminusVzm_s')*gUminusVzm_s,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Construct stop band constraint matrix
  bFzm_s=Fzm_s+gFzm_s;
  
  if m==1,
    printf("rows(Lzm_p)=%d\n",rows(Lzm_p));
    printf("rows(Fzm_p)=%d\n",rows(Fzm_p));
    printf("rows(Lzm_s)=%d\n",rows(Lzm_s));
    printf("rows(Fzm_s)=%d\n",rows(Fzm_s));
  endif

  % Define objective function
  if use_hessEsq
    Esqkdk=Esq+(gradEsq(1:N)*(dk'))+(dk*hessEsq(1:N,1:N)*(dk')/2);
  elseif use_updateHessEsqBfgs
    if m==1
      Esqkdk=Esq+(gradEsq(1:N)*(dk'))+(dk*hessEsq(1:N,1:N)*(dk')/2);
    else
      gmma=gradEsq(1:N)-last_gradEsq;
      last_gradEsq=gradEsq(1:N);
      [W,invW]=updateWbfgs(value(dk),gmma,W,invW);
      Esqkdk=Esq+(gradEsq(1:N)*(dk'))+(dk*W(1:N,1:N)*(dk')/2);
    endif
  else
    Esqkdk=Esq+(gradEsq(1:N)*(dk'));
  endif

  % Solve for the SDP variables
  rho=10^floor(log10(Esq));
  ctol=1e-5;
  Constraints=[ (-1+ctol)<=(k+dk)<=(1-ctol), ...
                  dEsq_p<=0,       dEsq_s<=0, ...
                  Esq_p+dEsq_p>=0, Esq_s+dEsq_s>=0, ...
                  bFzm_p<=ctol,    dQ_p>=0, ...
                  bFzm_s<=ctol,    dQ_s>=0 ];
  Objective=real(Esqkdk + (rho*norm(dz)^2));
  if use_scs
    Options=sdpsettings("solver","scs-direct","scs.max_iters",20000,
                        "scs.eps_abs",tol,"scs.eps_rel",tol);
  elseif use_sedumi
    Options=sdpsettings("solver","sedumi","sedumi.eps",tol);
  else
    Options=sdpsettings("solver","sdpt3","maxit",100,"gaptol",tol);
  endif
  sol=optimize(Constraints,Objective,Options)
  if sol.problem
    error("YALMIP failed");
  endif

  % Sanity checks
  check(Constraints)
  
  schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_update;

  % Exit criterion
  if norm(value(dk)) < tol
    break;
  elseif m==maxiter_kyp
    warning("Exiting at maxiter_kyp!");
    break;
  endif

endfor
 
schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_finish;

% Done
toc
diary off
movefile(strcat(strf,".diary.tmp"),strcat(strf,".diary"));
