% schurOneMPAlatticeDoublyPipelinedDelay_kyp_Dinh_lowpass_test.m
% Copyright (C) 2024 Robert G. Jenssen
%
% Design a Schur one-multiplier all-pass filter with the Finsler
% transformation of the KYP lemma and the BMI convex over-approximation
% of Dinh et al.. See: "Combining Convexâ€“Concave Decompositions and
% Linearization Approaches for Solving BMIs, With Application to Static Output
% Feedback", July, 2011. Available at:
%   https://set.kuleuven.be/optec/Software/softwarefiles/bmipaper
%
% N    rows(A)     rows(F)
%    2*((N+DD)+2)  3*rows(A)+3
% 4      18          57
% 5      22          69
% 6      26          81
% 7      30          93
% 8      34         105

test_common;

use_best_k_found=true

strf="schurOneMPAlatticeDoublyPipelinedDelay_kyp_Dinh_lowpass_test";
delete(strcat(strf,".diary"));
delete(strcat(strf,".diary.tmp"));
eval(sprintf("diary %s.diary.tmp",strf));

tic;

schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_start;

if use_best_k_found
  maxiter_succ_approx=0;
  
  printf("\n\nUsing best k found!\n\n");
  k = [  -0.5929031136,   0.3293844234,   0.1621855219,   0.0498198586 ];
%{
m=100 :
Esq_p=0.25882, dEsq_p=-1.97704e-05, Esq_s=0.000479986, dEsq_s=-5.28704e-11
value(Objective)=0.00281717
norm(value(dz))=0.000166735
dk = [ -3.2795e-06, 5.95349e-06, -2.47691e-06, 7.26166e-06 ];
k = [ -0.592903, 0.329384, 0.162186, 0.0498199 ];
10*log10(min(Asq))(pass)=-1.16075,10*log10(max(Asq))(stop)=-35.3269
Esq=0.00281714
gradEsq = [ -0.0707738, -0.0386171, -0.0271493, -0.0159534 ];
diagHessEsq = [ 1.64304, 0.419374, 0.224492, 0.12228 ];

10*log10(min(Asq))(pass)=-1.16075,10*log10(max(Asq))(stop)=-35.3269
Esq=0.00281714
gradEsq = [ -0.0707738, -0.0386171, -0.0271493, -0.0159534 ];
diagHessEsq = [ 1.64304, 0.419374, 0.224492, 0.12228 ];
k0 = [  -0.5963715857,   0.3207605628,   0.1541525927,   0.0461192156 ];
k = [  -0.5929031136,   0.3293844234,   0.1621855219,   0.0498198586 ];
Elapsed time is 6444.31 seconds.
%}
list_Esq = [ 0.0037695600, 0.0034792600, 0.0032723300, 0.0031312300, ...
             0.0030386100, 0.0029818700, 0.0029504800, 0.0029347800, ...
             0.0029265500, 0.0029207800, 0.0029158600, 0.0029113400, ...
             0.0029070900, 0.0029030600, 0.0028992100, 0.0028955200, ...
             0.0028919800, 0.0028885900, 0.0028853300, 0.0028822100, ...
             0.0028791900, 0.0028763000, 0.0028735000, 0.0028708700, ...
             0.0028682700, 0.0028658000, 0.0028634900, 0.0028612200, ...
             0.0028590700, 0.0028570000, 0.0028550200, 0.0028531300, ...
             0.0028513300, 0.0028495900, 0.0028479300, 0.0028463400, ...
             0.0028447900, 0.0028433400, 0.0028420000, 0.0028407000, ...
             0.0028394600, 0.0028382800, 0.0028371500, 0.0028360800, ...
             0.0028350100, 0.0028340300, 0.0028330900, 0.0028322000, ...
             0.0028313500, 0.0028305400, 0.0028297800, 0.0028290600, ...
             0.0028283600, 0.0028277100, 0.0028270900, 0.0028265100, ...
             0.0028259500, 0.0028254200, 0.0028249200, 0.0028244500, ...
             0.0028240000, 0.0028235800, 0.0028231800, 0.0028228000, ...
             0.0028224400, 0.0028221100, 0.0028217900, 0.0028214900, ...
             0.0028212000, 0.0028209300, 0.0028206800, 0.0028204400, ...
             0.0028202100, 0.0028200000, 0.0028198000, 0.0028196100, ...
             0.0028194300, 0.0028192600, 0.0028191000, 0.0028189500, ...
             0.0028188000, 0.0028186700, 0.0028185400, 0.0028184200, ...
             0.0028183100, 0.0028182000, 0.0028180900, 0.0028180000, ...
             0.0028179100, 0.0028178200, 0.0028177400, 0.0028176600, ...
             0.0028175900, 0.0028175200, 0.0028174600, 0.0028174000, ...
             0.0028173400, 0.0028172800, 0.0028172300, 0.0028171800, ...
             0.0028171400, 0.0028171400 ];
list_norm_dk = [ 0.0041935182, 0.0024759384, 0.0016662401, 0.0011102942, ... 
                 0.0007004478, 0.0004122303, 0.0002557444, 0.0002106510, ... 
                 0.0002050149, 0.0002011021, 0.0001962317, 0.0001909838, ... 
                 0.0001857712, 0.0001808251, 0.0001760921, 0.0001715734, ... 
                 0.0001672486, 0.0001630946, 0.0001590958, 0.0001552558, ... 
                 0.0001514982, 0.0001478862, 0.0001441044, 0.0001410174, ... 
                 0.0001374712, 0.0001339618, 0.0001307874, 0.0001274840, ... 
                 0.0001243064, 0.0001211700, 0.0001180777, 0.0001150341, ... 
                 0.0001120449, 0.0001090860, 0.0001061812, 0.0001032047, ... 
                 0.0001004707, 0.0000980505, 0.0000953781, 0.0000926941, ... 
                 0.0000900976, 0.0000875716, 0.0000850880, 0.0000821692, ... 
                 0.0000799218, 0.0000776691, 0.0000754255, 0.0000732233, ... 
                 0.0000710695, 0.0000689632, 0.0000668771, 0.0000648153, ... 
                 0.0000629082, 0.0000609621, 0.0000590243, 0.0000571099, ... 
                 0.0000552518, 0.0000534370, 0.0000516855, 0.0000499652, ... 
                 0.0000482813, 0.0000466363, 0.0000450300, 0.0000434605, ... 
                 0.0000419342, 0.0000404436, 0.0000389902, 0.0000375688, ... 
                 0.0000362059, 0.0000348670, 0.0000335470, 0.0000323148, ... 
                 0.0000310857, 0.0000298989, 0.0000287141, 0.0000276516, ... 
                 0.0000265658, 0.0000255233, 0.0000245192, 0.0000235488, ... 
                 0.0000226140, 0.0000217114, 0.0000207961, 0.0000200259, ... 
                 0.0000192075, 0.0000184264, 0.0000176806, 0.0000170844, ... 
                 0.0000163987, 0.0000156770, 0.0000149161, 0.0000144418, ... 
                 0.0000138284, 0.0000132630, 0.0000127180, 0.0000121900, ... 
                 0.0000116431, 0.0000111945, 0.0000107098, 0.0000102502 ];
else
  maxiter_succ_approx=100;
endif

for m=1:maxiter_succ_approx,

  % Constant part of the pass band constraint matrix
  Lzm_p=kron(Phi,P_p)+kron(Psi_p,Q_p);
  Uzm_p=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_p,D,-1]];
  Vzm_p=[[XYZ_p,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VplusUzm_p=(Uzm_p+(Vzm_p'))/sqrt(2);
  UminusVzm_p=(Uzm_p-(Vzm_p'))/sqrt(2);
  Fzm_p=[[[[Lzm_p,zeros(2*n,2)]; ...
           [zeros(1,2*n),-Esq_p,0]; ...
           [zeros(1,(2*n)+1),1]],(VplusUzm_p')]; ...
         [VplusUzm_p,-eye(n+1)]] - ...
        [[(UminusVzm_p')*UminusVzm_p,zeros(2*(n+1),n+1)]; ...
         [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Linear part of the pass band constraint matrix
  gLzm_p=kron(Phi,dP_p)+kron(Psi_p,dQ_p);
  gUzm_p=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_p=[[dXYZ_p,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVplusUzm_p=(gUzm_p+(gVzm_p'))/sqrt(2);
  gUminusVzm_p=(gUzm_p-(gVzm_p'))/sqrt(2);
  gFzm_p=[[[[gLzm_p,zeros(2*n,2)]; ...
            [zeros(1,2*n),-dEsq_p,0]; ...
            [zeros(1,(2*n)+1),0]],(gVplusUzm_p')]; ...
          [gVplusUzm_p,zeros(n+1)]] - ...
         [[(gUminusVzm_p')*UminusVzm_p,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]] - ...
         [[(UminusVzm_p')*gUminusVzm_p,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Construct pass band constraint matrix
  bFzm_p=Fzm_p+gFzm_p;

  % Constant part of the stop band constraint matrix
  Lzm_s=kron(Phi,P_s)+kron(Psi_s,Q_s);
  Uzm_s=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_s,D,-1]];
  Vzm_s=[[XYZ_s,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VplusUzm_s=(Uzm_s+(Vzm_s'))/sqrt(2);
  UminusVzm_s=(Uzm_s-(Vzm_s'))/sqrt(2);
  Fzm_s=[[[[Lzm_s,zeros(2*n,2)]; ...
           [zeros(1,2*n),-Esq_s,0]; ...
           [zeros(1,(2*n)+1),1]],(VplusUzm_s')]; ...
         [VplusUzm_s,-eye(n+1)]] - ...
        [[(UminusVzm_s')*UminusVzm_s,zeros(2*(n+1),n+1)]; ...
         [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Linear part of the stop band constraint matrix
  gLzm_s=kron(Phi,dP_s)+kron(Psi_s,dQ_s);
  gUzm_s=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_s=[[dXYZ_s,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVplusUzm_s=(gUzm_s+(gVzm_s'))/sqrt(2);
  gUminusVzm_s=(gUzm_s-(gVzm_s'))/sqrt(2);
  gFzm_s=[[[[gLzm_s,zeros(2*n,2)]; ...
            [zeros(1,2*n),-dEsq_s,0]; ...
            [zeros(1,(2*n)+1),0]],(gVplusUzm_s')]; ...
          [gVplusUzm_s,zeros(n+1)]] - ...
         [[(gUminusVzm_s')*UminusVzm_s,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]] - ...
         [[(UminusVzm_s')*gUminusVzm_s,zeros(2*(n+1),n+1)]; ...
          [zeros(n+1,2*(n+1)),zeros(n+1)]];

  % Construct stop band constraint matrix
  bFzm_s=Fzm_s+gFzm_s;
  
  if m==1,
    printf("rows(Lzm_p)=%d\n",rows(Lzm_p));
    printf("rows(Fzm_p)=%d\n",rows(Fzm_p));
    printf("rows(Lzm_s)=%d\n",rows(Lzm_s));
    printf("rows(Fzm_s)=%d\n",rows(Fzm_s));
  endif
   
  % Solve for the SDP variables
  [Esq,gradEsq,diagHessEsq]= ...
    schurOneMPAlatticeEsq(k,k1,k1,kDD,kDD1,kDD1,diff,wplot,Ad,Wa);
  Esqkdk=Esq+sum(gradEsq(1:N).*dk)+sum(dk.*diagHessEsq(1:N).*dk/2);
  Constraints=[ (-1+tol)<=(k+dk)<=(1-tol), ...
                dEsq_p<=0,   dEsq_s<=0, ...
                bFzm_p<=tol, dQ_p>=0, ...
                bFzm_s<=tol, dQ_s>=0 ];
  Objective=real(Esqkdk + (norm(dz)^2));
  Options=sdpsettings("solver","sdpt3","maxit",100,"gaptol",tol);
  sol=optimize(Constraints,Objective,Options)
  if sol.problem
    error("YALMIP failed");
  endif

  % Sanity checks
  check(Constraints)
  
  schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_update;

  % Exit criterion
  if norm(value(dk)) < tol
    break;
  elseif m==maxiter
    error("Failed at maxiter!");
  endif

endfor
 
schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_finish;

% Done
toc
diary off
movefile(strcat(strf,".diary.tmp"),strcat(strf,".diary"));
