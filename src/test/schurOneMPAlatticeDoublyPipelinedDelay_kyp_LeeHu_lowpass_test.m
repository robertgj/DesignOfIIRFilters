% schurOneMPAlatticeDoublyPipelinedDelay_kyp_LeeHu_lowpass_test.m
% Copyright (C) 2024 Robert G. Jenssen
%
% Design a Schur one-multiplier all-pass filter with the Finsler
% transformation of the KYP lemma and the BMI convex over-approximation
% of Lee and Hu. See: "A sequential parametric convex approximation method
% for solving bilinear matrix inequalities", D. Lee and J. Hu, July, 2016,
% https://engineering.purdue.edu/~jianghai/Publication/OPTL2018_BMI.pdf
%
% m    rows(A)     rows(F)        rows(S)        rows(bF)
%    2*((N+D)+2)  2*rows(A)+2    rows(A)+1   4*(rows(A)+1) [16*m+12]
% 4      18          38             19               76
% 5      22          46             23               92
% 6      26          54             27              108
% 7      30          62             31              124
% 8      34          68             35              140

test_common;

use_best_k_found=true;

strf="schurOneMPAlatticeDoublyPipelinedDelay_kyp_LeeHu_lowpass_test";
delete(strcat(strf,".diary"));
delete(strcat(strf,".diary.tmp"));
eval(sprintf("diary %s.diary.tmp",strf));

tic;

schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_start;

S_p=eye(n+1);
S_s=eye(n+1);

dS_p=sdpvar(n+1,n+1,"symmetric","real");
dS_s=sdpvar(n+1,n+1,"symmetric","real");

if use_best_k_found
  maxiter_succ_approx=0;

  printf("\n\nUsing best k found!\n\n");
  k = [  -0.5926552158,   0.3288599856,   0.1620660362,   0.0491325913 ];
%{
 m=64 :
Esq_p=0.243699, dEsq_p=-2.54813e-07, Esq_s=0.000479991, dEsq_s=-2.67791e-10
value(Objective)=0.00283412
norm(value(dz))=0.0100917
dk = [ -1.73676e-07, -3.3737e-07, -5.18392e-07, 1.70519e-07 ];
k = [ -0.592655, 0.32886, 0.162066, 0.0491326 ];
10*log10(min(Asq))(pass)=-1.16214,10*log10(max(Asq))(stop)=-35.1634
Esq=0.00283411
gradEsq = [ -0.0709442, -0.0387632, -0.0272574, -0.0160501 ];
diagHessEsq = [ 1.64266, 0.421615, 0.227279, 0.122146 ];
k0 = [  -0.5963715857,   0.3207605628,   0.1541525927,   0.0461192156 ];
k = [  -0.5926552158,   0.3288599856,   0.1620660362,   0.0491325913 ];
Elapsed time is 7359.59 seconds.
%}
list_Esq = [ 0.0037695600, 0.0034819300, 0.0032391600, 0.0030966100, ...
             0.0030108100, 0.0029623000, 0.0029367900, 0.0029233800, ...
             0.0029150100, 0.0029082400, 0.0029019100, 0.0028959700, ...
             0.0028904200, 0.0028852600, 0.0028804500, 0.0028760300, ...
             0.0028719000, 0.0028681000, 0.0028645900, 0.0028613700, ...
             0.0028584100, 0.0028557100, 0.0028532400, 0.0028509800, ...
             0.0028489300, 0.0028471000, 0.0028454300, 0.0028439600, ...
             0.0028426200, 0.0028414300, 0.0028403600, 0.0028394400, ...
             0.0028386200, 0.0028379000, 0.0028372800, 0.0028367300, ...
             0.0028362800, 0.0028358900, 0.0028355600, 0.0028353000, ...
             0.0028350800, 0.0028348900, 0.0028347100, 0.0028345700, ...
             0.0028344700, 0.0028343900, 0.0028343200, 0.0028342600, ...
             0.0028342100, 0.0028341700, 0.0028341300, 0.0028341200, ...
             0.0028341000, 0.0028340900, 0.0028340700, 0.0028340500, ...
             0.0028341300, 0.0028340800, 0.0028340800, 0.0028340700, ...
             0.0028340800, 0.0028340900, 0.0028340800, 0.0028340700, ...
             0.0028341100, 0.0028341100 ];
list_norm_dk = [ 0.0042663670, 0.0028771105, 0.0016911390, 0.0010316693, ...
                 0.0005901812, 0.0003610879, 0.0003090076, 0.0003043155, ...
                 0.0003174514, 0.0003113265, 0.0002911230, 0.0002733187, ...
                 0.0002602670, 0.0002494168, 0.0002395604, 0.0002295047, ...
                 0.0002194675, 0.0002093338, 0.0001997094, 0.0001898178, ...
                 0.0001805036, 0.0001713998, 0.0001631124, 0.0001542706, ...
                 0.0001440647, 0.0001377780, 0.0001276718, 0.0001216370, ...
                 0.0001140068, 0.0001060675, 0.0000975296, 0.0000919921, ...
                 0.0000856704, 0.0000784678, 0.0000724551, 0.0000653372, ...
                 0.0000598581, 0.0000544377, 0.0000512719, 0.0000451396, ...
                 0.0000389643, 0.0000349601, 0.0000295351, 0.0000274086, ...
                 0.0000230539, 0.0000208162, 0.0000180597, 0.0000149214, ...
                 0.0000148260, 0.0000123084, 0.0000113079, 0.0000057864, ...
                 0.0000076064, 0.0000063628, 0.0000085951, 0.0000051903, ...
                 0.0000072758, 0.0000043050, 0.0000033756, 0.0000026812, ...
                 0.0000020146, 0.0000033334, 0.0000023529, 0.0000006647 ];
else
  maxiter_succ_approx=100;
endif

for m=1:maxiter_succ_approx,

  % Constant part of the pass band constraint matrix
  Lzm_p=kron(Phi,P_p)+kron(Psi_p,Q_p);
  Uzm_p=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_p,D,-1]];
  Vzm_p=[[XYZ_p,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VUzm_p=Vzm_p*Uzm_p;
  Fzm_p=[[Lzm_p,zeros(2*n,2)]; ...
         [zeros(1,2*n),-Esq_p,0]; ...
         [zeros(1,(2*n)+1),1]] + ...
        VUzm_p + (VUzm_p');

  % Linear part of the pass band constraint matrix
  gLzm_p=kron(Phi,dP_p)+kron(Psi_p,dQ_p);
  gUzm_p=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_p=[[dXYZ_p,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVUzm_p=(gVzm_p*Uzm_p)+(Vzm_p*gUzm_p);
  gFzm_p=[[gLzm_p,zeros(2*n,1),zeros(2*n,1)]; ...
          [zeros(1,2*n),-dEsq_p,0]; ...
          [zeros(1,2*n),0,0]] + ...
         gVUzm_p + (gVUzm_p');

  % Construct pass band constraint matrix
  SgVzm_p=S_p*(gVzm_p');
  bFzm_p=[[(Fzm_p+gFzm_p),(SgVzm_p'),gUzm_p']; ...
          [SgVzm_p,(-(2*S_p)+dS_p),zeros(n+1)]; ...
          [gUzm_p,zeros(n+1),-dS_p]];

  % Constant part of the stop band constraint matrix
  Lzm_s=kron(Phi,P_s)+kron(Psi_s,Q_s);
  Uzm_s=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_s,D,-1]];
  Vzm_s=[[XYZ_s,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VUzm_s=Vzm_s*Uzm_s;
  Fzm_s=[[Lzm_s,zeros(2*n,2)]; ...
         [zeros(1,2*n),-Esq_s,0]; ...
         [zeros(1,(2*n)+1),1]] + ...
        VUzm_s + (VUzm_s');

  % Linear part of the stop band constraint matrix
  gLzm_s=kron(Phi,dP_s)+kron(Psi_s,dQ_s);
  gUzm_s=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_s=[[dXYZ_s,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVUzm_s=(gVzm_s*Uzm_s)+(Vzm_s*gUzm_s);
  gFzm_s=[[gLzm_s,zeros(2*n,1),zeros(2*n,1)]; ...
          [zeros(1,2*n),-dEsq_s,0]; ...
          [zeros(1,2*n),0,0]] + ...
         gVUzm_s + (gVUzm_s');

  % Construct stop band constraint matrix
  SgVzm_s=S_s*(gVzm_s');
  bFzm_s=[[(Fzm_s+gFzm_s),(SgVzm_s'),gUzm_s']; ...
          [SgVzm_s,(-(2*S_s)+dS_s),zeros(n+1)]; ...
          [gUzm_s,zeros(n+1),-dS_s]];

  % Solve for the SDP variables
  [Esq,gradEsq,diagHessEsq]= ...
    schurOneMPAlatticeEsq(k,k1,k1,kDD,kDD1,kDD1,diff,wplot,Ad,Wa);
  Esqkdk=Esq+sum(gradEsq(1:N).*dk)+sum(dk.*diagHessEsq(1:N).*dk/2);
  rho=10^floor(log10(Esq)-1);
  c1=tol;c2=1e4;c3=tol;
  Constraints=[ (-1+tol)<=(k+dk)<=(1-tol), ...
                dEsq_p<=0, ...
                dEsq_s<=0, ...
                bFzm_p<=tol, dQ_p>=0, dS_p>=0, ...
                bFzm_s<=tol, dQ_s>=0, dS_s>=0, ...
                c1*eye(n+1)<=dS_p<=c2*eye(n+1), ...
                c1*eye(n+1)<=dS_s<=c2*eye(n+1), ...
                ((-2*S_p)+dS_p)<=-c3*eye(n+1), ...
                ((-2*S_s)+dS_s)<=-c3*eye(n+1) ];
  Objective=real(Esqkdk + (rho*norm(dz)^2));
  Options=sdpsettings("solver","sdpt3","maxit",100,"gaptol",tol);
  sol=optimize(Constraints,Objective,Options)
  if sol.problem
    error("YALMIP failed");
  endif
  
  % Sanity checks
  check(Constraints)
  
  S_p=value(dS_p);
  S_s=value(dS_s);

  schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_update;

  % Exit criterion
  if norm(value(dk)) < tol
    break;
  elseif m==maxiter
    error("Failed at maxiter!");
  endif

endfor
 
schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_finish;

% Done
toc
diary off
movefile(strcat(strf,".diary.tmp"),strcat(strf,".diary"));
