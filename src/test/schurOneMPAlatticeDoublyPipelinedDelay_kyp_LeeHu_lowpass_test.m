% schurOneMPAlatticeDoublyPipelinedDelay_kyp_LeeHu_lowpass_test.m
% Copyright (C) 2024 Robert G. Jenssen
%
% Design a Schur one-multiplier all-pass filter with the Finsler
% transformation of the KYP lemma and the BMI convex over-approximation
% of Lee and Hu. See: "A sequential parametric convex approximation method
% for solving bilinear matrix inequalities", D. Lee and J. Hu, July, 2016,
% https://engineering.purdue.edu/~jianghai/Publication/OPTL2018_BMI.pdf
%
% m    rows(A)     rows(F)        rows(S)        rows(bF)
%    2*((N+D)+2)  2*rows(A)+2    rows(A)+1   4*(rows(A)+1) [16*m+12]
% 4      18          38             19               76
% 5      22          46             23               92
% 6      26          54             27              108
% 7      30          62             31              124
% 8      34          68             35              140

test_common;

strf="schurOneMPAlatticeDoublyPipelinedDelay_kyp_LeeHu_lowpass_test";
delete(strcat(strf,".diary"));
delete(strcat(strf,".diary.tmp"));
eval(sprintf("diary %s.diary.tmp",strf));

tic;

schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_start;

use_best_k_found=true;
use_hessEsq=true
use_sedumi=false
use_scs=false
maxiter_kyp=50;

S_p=eye(n+1);
S_s=eye(n+1);

dS_p=sdpvar(n+1,n+1,"symmetric","real");
dS_s=sdpvar(n+1,n+1,"symmetric","real");

if use_best_k_found
  maxiter_succ_approx=0;
  printf("\n\nUsing best k found!\n\n");
  %10*log10(min(Asq))(pass)=-0.11768,10*log10(max(Asq))(stop)=-42.9579
  Esq=2.80252e-06
  gradEsq = [ -5.10449e-05, -4.52986e-05, 3.06807e-05, 3.34673e-05, ... 
              -1.72426e-05 ];
  diagHessEsq = [ 0.0205217, 0.0312588, 0.0328725, 0.0341598, ... 
                  0.0380711 ];
  k0 = [  -0.5887890122,   0.3794825489,   0.2077136416,   0.0867433777, ... 
           0.0216280074 ];
  k = [   -0.5581684326,   0.4173974552,   0.2272280561,   0.0934981472, ... 
           0.0182224663 ];
  list_norm_dk = [ 0.0035376577, 0.0031034946, 0.0028007106, 0.0029235272, ... 
       0.0029640859, 0.0028875790, 0.0027157847, 0.0024556254, ... 
       0.0024054468, 0.0025438878, 0.0027737537, 0.0023447519, ... 
       0.0021250281, 0.0013927142, 0.0023154608, 0.0012279090, ... 
       0.0014385965, 0.0013009380, 0.0021910546, 0.0008409685, ... 
       0.0006489517, 0.0016308836, 0.0005341275, 0.0008359497, ... 
       0.0009153425, 0.0004546078, 0.0005631659, 0.0002846754, ... 
       0.0003166294, 0.0002715714, 0.0011211852, 0.0006256431, ... 
       0.0006424450, 0.0004075415, 0.0002372949, 0.0002026256, ... 
       0.0001531433, 0.0003821603, 0.0004616205, 0.0011204246, ... 
       0.0005038176, 0.0004245471, 0.0001256960, 0.0008840156, ... 
       0.0002686333, 0.0009710903, 0.0002494926, 0.0001183030, ... 
       0.0002246872, 0.0004224663 ]';
  list_Esq = [ 0.0000365167, 0.0000314782, 0.0000272455, 0.0000234265, ... 
       0.0000200223, 0.0000170912, 0.0000146697, 0.0000127343, ... 
       0.0000110565, 0.0000095245, 0.0000081489, 0.0000071006, ... 
       0.0000062649, 0.0000057667, 0.0000050633, 0.0000047301, ... 
       0.0000043771, 0.0000040945, 0.0000036849, 0.0000035490, ... 
       0.0000034512, 0.0000032247, 0.0000032027, 0.0000031007, ... 
       0.0000030042, 0.0000029807, 0.0000030079, 0.0000029816, ... 
       0.0000029639, 0.0000029429, 0.0000028436, 0.0000027925, ... 
       0.0000028327, 0.0000028059, 0.0000028103, 0.0000028041, ... 
       0.0000028042, 0.0000027788, 0.0000028103, 0.0000027326, ... 
       0.0000027655, 0.0000027371, 0.0000027347, 0.0000027972, ... 
       0.0000028159, 0.0000027493, 0.0000027652, 0.0000027597, ... 
       0.0000027738, 0.0000028025 ]';
  list_Asq_min = [ 0.8861923808, 0.8933616289, 0.8999682639, 0.9064032651, ... 
       0.9126641311, 0.9185878223, 0.9239224604, 0.9285359006, ... 
       0.9329630398, 0.9374202283, 0.9420372359, 0.9458353022, ... 
       0.9491491280, 0.9512552036, 0.9545974707, 0.9563602105, ... 
       0.9583237847, 0.9600458009, 0.9628769915, 0.9639075752, ... 
       0.9646946396, 0.9666656847, 0.9669533426, 0.9679257924, ... 
       0.9689755256, 0.9693290606, 0.9692023630, 0.9695069439, ... 
       0.9698049766, 0.9700892778, 0.9712559762, 0.9719139784, ... 
       0.9716323106, 0.9720775150, 0.9721486142, 0.9723312452, ... 
       0.9724131189, 0.9728176184, 0.9724784577, 0.9735108393, ... 
       0.9732206469, 0.9736258843, 0.9735813913, 0.9730582443, ... 
       0.9728644090, 0.9737131186, 0.9736277460, 0.9737537949, ... 
       0.9735981817, 0.9732670036 ]';
  list_Asq_max = [ 0.0000369780, 0.0000404858, 0.0000484677, 0.0000493913, ... 
       0.0000486570, 0.0000479786, 0.0000456098, 0.0000418087, ... 
       0.0000408192, 0.0000418424, 0.0000465730, 0.0000464683, ... 
       0.0000448386, 0.0000461949, 0.0000467932, 0.0000487967, ... 
       0.0000504523, 0.0000515166, 0.0000521710, 0.0000530740, ... 
       0.0000539670, 0.0000552713, 0.0000543818, 0.0000555147, ... 
       0.0000558813, 0.0000552676, 0.0000531783, 0.0000534292, ... 
       0.0000529483, 0.0000529374, 0.0000548687, 0.0000559759, ... 
       0.0000540401, 0.0000541243, 0.0000534669, 0.0000532332, ... 
       0.0000529528, 0.0000534232, 0.0000523939, 0.0000545727, ... 
       0.0000531744, 0.0000540666, 0.0000549042, 0.0000514028, ... 
       0.0000506912, 0.0000530857, 0.0000520601, 0.0000521428, ... 
       0.0000516456, 0.0000506072 ]';
else
  maxiter_succ_approx=maxiter_kyp;
endif

for m=1:maxiter_succ_approx,

  % Constant part of the pass band constraint matrix
  P_p=zeros(size(P_p));
  Q_p=zeros(size(Q_p));
  Lzm_p=kron(Phi,P_p)+kron(Psi_p,Q_p);
  Uzm_p=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_p,D,-1]];
  Vzm_p=[[XYZ_p,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VUzm_p=Vzm_p*Uzm_p;
  Fzm_p=[[Lzm_p,zeros(2*n,2)]; ...
         [zeros(1,2*n),-Esq_p,0]; ...
         [zeros(1,(2*n)+1),1]] + ...
        VUzm_p + (VUzm_p');

  % Linear part of the pass band constraint matrix
  gLzm_p=kron(Phi,dP_p)+kron(Psi_p,dQ_p);
  gUzm_p=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_p=[[dXYZ_p,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVUzm_p=(gVzm_p*Uzm_p)+(Vzm_p*gUzm_p);
  gFzm_p=[[gLzm_p,zeros(2*n,1),zeros(2*n,1)]; ...
          [zeros(1,2*n),-dEsq_p,0]; ...
          [zeros(1,2*n),0,0]] + ...
         gVUzm_p + (gVUzm_p');

  % Construct pass band constraint matrix
  SgVzm_p=S_p*(gVzm_p');
  bFzm_p=[[(Fzm_p+gFzm_p),(SgVzm_p'),gUzm_p']; ...
          [SgVzm_p,(-(2*S_p)+dS_p),zeros(n+1)]; ...
          [gUzm_p,zeros(n+1),-dS_p]];

  % Constant part of the stop band constraint matrix
  P_s=zeros(size(P_s));
  Q_s=zeros(size(Q_s));
  Lzm_s=kron(Phi,P_s)+kron(Psi_s,Q_s);
  Uzm_s=[[-eye(n),A,B,zeros(n,1)]; ...
         [zeros(1,n),C_s,D,-1]];
  Vzm_s=[[XYZ_s,zeros((2*n)+1,1)]; ...
         [zeros(1,n),1]];
  VUzm_s=Vzm_s*Uzm_s;
  Fzm_s=[[Lzm_s,zeros(2*n,2)]; ...
         [zeros(1,2*n),-Esq_s,0]; ...
         [zeros(1,(2*n)+1),1]] + ...
        VUzm_s + (VUzm_s');

  % Linear part of the stop band constraint matrix
  gLzm_s=kron(Phi,dP_s)+kron(Psi_s,dQ_s);
  gUzm_s=[[zeros(n),dA,zeros(n,1),zeros(n,1)]; ...
          [zeros(1,n),zeros(1,n),0,0]];
  gVzm_s=[[dXYZ_s,zeros((2*n)+1,1)]; ...
          [zeros(1,n),0]];
  gVUzm_s=(gVzm_s*Uzm_s)+(Vzm_s*gUzm_s);
  gFzm_s=[[gLzm_s,zeros(2*n,1),zeros(2*n,1)]; ...
          [zeros(1,2*n),-dEsq_s,0]; ...
          [zeros(1,2*n),0,0]] + ...
         gVUzm_s + (gVUzm_s');

  % Construct stop band constraint matrix
  SgVzm_s=S_s*(gVzm_s');
  bFzm_s=[[(Fzm_s+gFzm_s),(SgVzm_s'),gUzm_s']; ...
          [SgVzm_s,(-(2*S_s)+dS_s),zeros(n+1)]; ...
          [gUzm_s,zeros(n+1),-dS_s]];

  % Define objective function
  if use_hessEsq
    Esqkdk=Esq+(gradEsq(1:N)*(dk'))+(dk*hessEsq(1:N,1:N)*(dk')/2);
  else
    Esqkdk=Esq+(gradEsq(1:N)*(dk'));
  endif

  % Solve for the SDP variables
  rho=10^floor(log10(Esq));
  ctol=1e-5;
  c1=ctol;c2=1e4;c3=ctol;
  Constraints=[ (-1+tol)<=(k+dk)<=(1-tol), ...
                dEsq_p<=0, ...
                dEsq_s<=0, ...
                Esq_p+dEsq_p>=0, ...
                Esq_s+dEsq_s>=0, ...
                bFzm_p<=ctol, dQ_p>=0, dS_p>=0, ...
                bFzm_s<=ctol, dQ_s>=0, dS_s>=0, ...
                c1*eye(n+1)<=dS_p<=c2*eye(n+1), ...
                c1*eye(n+1)<=dS_s<=c2*eye(n+1), ...
                ((-2*S_p)+dS_p)<=-c3*eye(n+1), ...
                ((-2*S_s)+dS_s)<=-c3*eye(n+1) ];
  Objective=real(Esqkdk + (rho*norm(dz)^2));
  if use_scs
    Options=sdpsettings("solver","scs-direct","scs.max_iters",20000,
                        "scs.eps_abs",tol,"scs.eps_rel",tol);
  elseif use_sedumi
    Options=sdpsettings("solver","sedumi","sedumi.eps",tol);
  else
    Options=sdpsettings("solver","sdpt3","maxit",100,"gaptol",tol);
  endif
  sol=optimize(Constraints,Objective,Options)
  if sol.problem
    error("YALMIP failed");
  endif
  
  % Sanity checks
  check(Constraints)
  
  S_p=value(dS_p);
  S_s=value(dS_s);

  schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_update;

  % Exit criterion
  if norm(value(dk)) < tol
    break;
  elseif m==maxiter_kyp
    warning("Exiting at maxiter_kyp!");
    break;
  endif

endfor
 
schurOneMPAlatticeDoublyPipelinedDelay_kyp_lowpass_common_finish;

% Done
toc
diary off
movefile(strcat(strf,".diary.tmp"),strcat(strf,".diary"));
