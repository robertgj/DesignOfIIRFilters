function svcasc2cc(a11,a12,a21,a22,b1,b2,c1,c2,d,bits,name)
% svcasc2cc(a11,a12,a21,a22,b1,b2,c1,c2,d,bits,name)
% Generate code for a state variable filter given as a
% cascade of second order sections. bits is the number
% of bits in the coefficients for each section. The
% function assumes there is no decimation in time.
%
% The signature of the generated function is:
%     WORD filter_name(const WORD u, RowVector &x1, RowVector &x2);
% For each input value, u, filter_name returns an output value. The
% updated state variables are returned in row vectors x1 and x2 
% containing the corresponding state variable for each section in the
% filter.

% Copyright (C) 2017 Robert G. Jenssen
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation
% files (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions: The above copyright notice and
% this permission notice shall be included in all copies or substantial
% portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
% IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
% CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
% TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
% SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

if nargin ~= 11
  print_usage("svcasc2cc(a11,a12,a21,a22,b1,b2,c1,c2,d,bits,name)");
endif
sections = length(d);
if sections ~= length(a11) || sections ~= length(a12) || ...
   sections ~= length(a21) || sections ~= length(a22) || ...
   sections ~= length(b1)  || sections ~= length(b2)  || ...
   sections ~= length(c1)  || sections ~= length(c2)  || ...
   sections ~= length(b1)  || sections ~= length(b2)
  error("Expect section coefficient vectors to have equal length!");
endif
if ~isscalar(bits)
  error("bits is not a scalar");
endif

%
% Output scale factor
%
scale = 2^(bits-1);

%
% Open file
%
fid=fopen(strcat(name,".cc"),"w");

%
% Banner
%
fprintf(fid,"// Generated by svcasc2cc.m for the %s filter.",name);
fprintf(fid,"\n// Compile with :");
fprintf(fid,"\n//\t\"mkoctfile(\"%s.cc\",\"-D USING_OCTAVE -Wall\")\"",name);
fprintf(fid,"\n//");
fprintf(fid,"\n// This file is linked with Octave and so is a derivative");
fprintf(fid,"\n// work and is subject to the GPLv3 or later. Accordingly");
fprintf(fid,"\n// the following notice applies:");
fprintf(fid,"\n//");
fprintf(fid,"\n// This program is free software; you can redistribute it");
fprintf(fid,"\n// and/or modify it underthe terms of the GNU General Public");
fprintf(fid,"\n// License as published by the Free Software Foundation;");
fprintf(fid,"\n// either version 3 of the License, or (at your option)");
fprintf(fid,"\n// any later version. This program is distributed in the");
fprintf(fid,"\n// hope that it will be useful, but WITHOUT ANY WARRANTY;");
fprintf(fid,"\n// without even the implied warranty of MERCHANTABILITY");
fprintf(fid,"\n// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU");
fprintf(fid,"\n// General Public License for more details. You should");
fprintf(fid,"\n// have received a copy of the GNU General Public License");
fprintf(fid,"\n// along with this program. If not, see:");
fprintf(fid,"\n// <http://www.gnu.org/licenses/>.");

%
% For mkoctfile
%
fprintf(fid,"\n\n#if defined(USING_OCTAVE)");

%
% Octfile definitions
% 
fprintf(fid,"\n\n#include <math.h>");
fprintf(fid,"\n\n#include <octave/oct.h>");

%
% Forward definitions
%
fprintf(fid,"\n\ntypedef double WORD;");
fprintf(fid,"\ntypedef double MAC;");
fprintf(fid,"\n\nvoid filter_%s_init(void);",name);
fprintf(fid,"\nWORD filter_%s(const WORD u,RowVector &x1,RowVector &x2);",name);

%
% Octfile function
%
fprintf(fid,
        sprintf("\n\nDEFUN_DLD(%s, args, nargout,\"[y,xx1,xx2]=%s(u)\")",
                name,name));
fprintf(fid,"\n{");
% Sanity check
fprintf(fid,"\n\t// Sanity check");
fprintf(fid,"\n\tif (args.length() != 1)")
fprintf(fid,"\n\t{");
fprintf(fid,"\n\t\tprint_usage();");
fprintf(fid,"\n\t\treturn octave_value();");
fprintf(fid,"\n\t}");
% Input argument
fprintf(fid,"\n\n\t// Input argument");
fprintf(fid,"\n\tint64_t N = args(0).length();");
fprintf(fid,"\n\tColumnVector u = args(0).vector_value();");
% Output arguments
fprintf(fid,"\n\n\t// Output arguments");
fprintf(fid,"\n\tColumnVector y(N);");
fprintf(fid,"\n\tRowVector x1(%d);",sections);
fprintf(fid,"\n\tRowVector x2(%d);",sections);
fprintf(fid,"\n\tMatrix xx1(N,%d);",sections);
fprintf(fid,"\n\tMatrix xx2(N,%d);",sections);
% Call the filter
fprintf(fid,"\n\n\t// Call the filter");
fprintf(fid,"\n\tfilter_%s_init();",name);
fprintf(fid,"\n\tfor(int64_t k=0; k<N; k++)");
fprintf(fid,"\n\t\t{");
fprintf(fid,"\n\t\t\ty(k) = filter_%s(u(k),x1,x2);", name);
fprintf(fid,"\n\t\t\txx1.insert(x1,k,0);");
fprintf(fid,"\n\t\t\txx2.insert(x2,k,0);");
fprintf(fid,"\n\t\t}");
fprintf(fid,"\n\n\t// Done");
fprintf(fid,"\n\toctave_value_list retval(3);");
fprintf(fid,"\n\tretval(0)=y;");
fprintf(fid,"\n\tretval(1)=xx1;");
fprintf(fid,"\n\tretval(2)=xx2;");
fprintf(fid,"\n\treturn retval;");
fprintf(fid,"\n}");

%
% If using mkoctfile
%
fprintf(fid,"\n\n#endif // USING_OCTAVE");

%
% Make the state storage file static to avoid initialisation problems
%
for k=1:sections
  fprintf(fid,"\nstatic WORD x1_%d = 0;",k);
  fprintf(fid,"\nstatic WORD x2_%d = 0;",k);
endfor

%
% A routine to initialise the static state storage
%
fprintf(fid,"\n\nvoid filter_%s_init(void)",name);
fprintf(fid,"\n{");
for k=1:sections
  fprintf(fid,"\n\tx1_%d = 0;",k);
  fprintf(fid,"\n\tx2_%d = 0;",k);
endfor
fprintf(fid,"\n}");

%
% A routine to scale the accumulator output
%
fprintf(fid,"\n\nstatic WORD filter_scale_output(MAC mac)");
fprintf(fid,"\n{");
fprintf(fid,"\n\treturn round(mac/%d);", scale);
fprintf(fid,"\n}");

%
% Print the function
%
fprintf(fid,"\n\nWORD filter_%s(const WORD u,RowVector &x1,RowVector &x2)",name);
fprintf(fid,"\n{");

%
% Print the coefficients
%
for k=1:sections
  fprintf(fid,"\n\tstatic const WORD a11_%d = %d;", k, round(scale*a11(k)));
  fprintf(fid,"\n\tstatic const WORD a12_%d = %d;", k, round(scale*a12(k)));
  fprintf(fid,"\n\tstatic const WORD a21_%d = %d;", k, round(scale*a21(k)));
  fprintf(fid,"\n\tstatic const WORD a22_%d = %d;", k, round(scale*a22(k)));
  fprintf(fid,"\n\tstatic const WORD b1_%d  = %d;", k, round(scale*b1(k)));
  fprintf(fid,"\n\tstatic const WORD b2_%d  = %d;", k, round(scale*b2(k)));
  fprintf(fid,"\n\tstatic const WORD c1_%d  = %d;", k, round(scale*c1(k)));
  fprintf(fid,"\n\tstatic const WORD c2_%d  = %d;", k, round(scale*c2(k)));
  fprintf(fid,"\n\tstatic const WORD d_%d   = %d;", k, round(scale*d(k)));
endfor

%
% Print the local variables
%
for k=1:sections
  fprintf(fid,"\n\tWORD x1_%dtmp;",k);
  fprintf(fid,"\n\tWORD x2_%dtmp;",k);
endfor
for k=0:sections
  fprintf(fid,"\n\tWORD y_%d;",k);
endfor
fprintf(fid,"\n\tWORD y;");
fprintf(fid,"\n\tMAC mac;");

%
% Make the section outputs
%
fprintf(fid,"\n\n\t// Set section 1 input");
fprintf(fid,"\n\ty_0 = u;");
for k=1:sections
  fprintf(fid,"\n\n\t// Calculate section %d output",k);
  fprintf(fid,"\n\tmac = 0;");
  for y=1:2
    fprintf(fid,"\n\tmac += c%d_%d*x%d_%d;",y,k,y,k);
  endfor
  fprintf(fid,"\n\tmac += d_%d*y_%d;",k,k-1);
  fprintf(fid,"\n\ty_%d = filter_scale_output(mac);",k);
endfor

%
% Make the final output
%
fprintf(fid,"\n\n\t// Set the filter output");
fprintf(fid,"\n\ty = y_%d;\n",sections);

%
% Make the state updates
%
for k=1:sections
  fprintf(fid,"\n\n\t// Set the state for section %d", k);
  for row=1:2
    fprintf(fid,"\n\tx%d_%dtmp = x%d_%d;",row,k,row,k);
  endfor
  for row=1:2
    fprintf(fid,"\n\tmac = 0;");
    for col=1:2
      fprintf(fid,"\n\tmac += a%d%d_%d*x%d_%dtmp;",row,col,k,col,k);
    endfor
    fprintf(fid,"\n\tmac += b%d_%d*y_%d;",row,k,k-1);
    fprintf(fid,"\n\tx%d_%d = filter_scale_output(mac);", row,k);
  endfor
endfor

%
% Return the state variables
%
fprintf(fid,"\n\n\t// Set the returned state for each section");
for k=1:sections
  for row=1:2
    fprintf(fid,"\n\tx%d(%d) = x%d_%d;",row,k-1,row,k);
  endfor
endfor

%
% Done
%
fprintf(fid,"\n\n\t// Done");
fprintf(fid,"\n\treturn(y);");
fprintf(fid,"\n}\n");
fclose(fid);

endfunction
